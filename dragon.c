#include <stdio.h> // 표준 입출력 라이브러리 (printf, scanf 등)
#include <stdlib.h> // 표준 유틸리티 라이브러리 (rand, srand, malloc, free, atoi 등)
#include <unistd.h> // POSIX 운영체제 API (usleep 등 시간 지연 함수)
#include <termios.h> // 터미널 I/O 설정 (예: 즉시 키 입력 처리를 위한 raw 모드)
#include <string.h> // 문자열 조작 함수 (memcpy, strcmp 등)
#include <time.h> // 시간 관련 함수 (특히 rand() 시드 설정용)
#include <fcntl.h> // 파일 제어 옵션 (여기서는 비블로킹 입력용)
#include <stdbool.h> // 불리언 타입 (true/false) 사용을 위한 헤더

// 맵 크기 정의
#define ROW 20 // 게임 맵의 행(세로) 개수
#define COL 40 // 게임 맵의 열(가로) 개수
#define MAX_FIREBALLS 20 // 동시에 존재할 수 있는 파이어볼/탄환의 최대 개수
#define MAX_MONSTERS 20 // 동시에 존재할 수 있는 몬스터의 최대 개수
#define MONSTER_MOVE_DELAY 50 // 몬스터 이동 주기 (프레임 단위)
#define MONSTER_SHOOT_DELAY 50 // 몬스터 탄환 발사 주기 (프레임 단위)
#define MONSTER_BULLET_MOVE_DELAY 3 // 몬스터 탄환 이동 속도 제어 (클수록 느려짐)
#define MONSTER_RESPAWN_DELAY 300 // 죽은 몬스터가 다시 나타나기까지의 지연 시간 (프레임 단위)

// 플레이어 위치 전역 변수
int playerX = 1, playerY = 18; // 플레이어의 초기 X, Y 좌표

// 드래곤 브레스 전역 변수 (스킬 방향 설정용)
int dirX = 1; // 드래곤 브레스의 X 방향 (초기값: 오른쪽)
int dirY = 0; // 드래곤 브레스의 Y 방향 (초기값: 수직 이동 없음)

// 몬스터 리젠(재생성) 전역 변수
int monsterRespawnTimer[MAX_MONSTERS] = {0}; // 각 몬스터의 리젠 타이머
int monsterOriginX[MAX_MONSTERS]; // 몬스터 리젠 시 원래 X 위치 저장
int monsterOriginY[MAX_MONSTERS]; // 몬스터 리젠 시 원래 Y 위치 저장

// 퀘스트 전역 변수
int queststop = 0; // 퀘스트 완료 메시지 출력을 제어하는 플래그
int rewardGiven[5] = {0}; // 각 퀘스트의 보상 지급 여부 추적 배열
int questAccepted[5] = {0};    // 각 퀘스트의 수락 여부 추적 배열
int questCompleted[5] = {0};   // 각 퀘스트의 완료 여부 추적 배열
int questKillCount[5] = {0};   // 각 퀘스트의 몬스터 처치 수 카운터
int questItemCount[5] = {0};   // 각 퀘스트의 아이템 수집 수 카운터
int inventory[10] = {0};       // 인벤토리 배열 (0번 인덱스는 여의주 조각, 9번 인덱스는 완성된 여의주)
int hasKey = 0; // 히든 맵 열쇠 소유 여부 플래그

// 플레이어 이모지 설정
int currentEmoji = 0;  // 0: 뱀 🐍, 1: 용 🐉
char* playerEmojis[] = {"🐍 ", "🐉 "}; // 플레이어 이모지 배열

// 몬스터 이모지 설정
const char* monsterEmojis[5] = {
    "🐌",  // 던전 1: 달팽이 이모지
    "🦎",  // 던전 2: 도마뱀 이모지
    "🕷️ ", // 던전 3: 맹독 거미 이모지
    "🧛",  // 던전 4: 드라큘라 이모지
    "🦖"    // 던전 5: 혼테일 이모지 (보스)
};

// 몬스터 구조체 정의
typedef struct {
    int x, y; // 몬스터의 현재 위치
    int hp; // 몬스터의 현재 체력
    int alive; // 생존 여부 플래그 (1: 살아있음, 0: 죽음)
    int move_counter; // 몬스터 이동 딜레이 카운터
    int shoot_counter; // 몬스터 탄환 발사 딜레이 카운터
    int type;  // 몬스터 종류 (0 = 달팽이, 1 = 도마뱀 등)
    
} Monster;

Monster monsters[MAX_MONSTERS]; // 여러 몬스터를 저장할 배열
int monsterCount = 0; // 현재 활성화된 몬스터 수

// 파이어볼 및 몬스터 탄환 구조체 정의
typedef struct {
    int x, y; // 파이어볼/탄환의 현재 위치
    int dx, dy; // 이동 방향 (x 변화량, y 변화량)
    int active; // 활성화 여부 플래그 (true: 활성화, false: 비활성화)
    int is_monster_bullet; // 몬스터 탄환 여부 (1: 몬스터 탄환, 0: 플레이어 파이어볼)
    int damage;  // 파이어볼/탄환의 데미지 값
    int move_counter; // 탄환 이동 딜레이 카운터
} Fireball;

Fireball fireballs[MAX_FIREBALLS]; // 여러 파이어볼/탄환을 저장할 배열

// 터미널 설정 백업용 구조체
struct termios orig_termios;

// 몬스터 생성 함수
void spawnMonster(int x, int y, int type) {
    if (monsterCount < MAX_MONSTERS) { // 몬스터를 생성할 공간이 있는지 확인
        monsters[monsterCount].x = x; // 몬스터의 초기 X 위치 설정
        monsters[monsterCount].y = y; // 몬스터의 초기 Y 위치 설정
        monsters[monsterCount].alive = 1; // 몬스터를 살아있는 상태로 표시
        monsterOriginX[monsterCount] = monsters[monsterCount].x;    // 리젠을 위해 원래 X 위치 저장
        monsterOriginY[monsterCount] = monsters[monsterCount].y;    // 리젠을 위해 원래 Y 위치 저장
        monsters[monsterCount].move_counter = 0; // 이동 카운터 초기화
        monsters[monsterCount].shoot_counter = 0; // 발사 카운터 초기화
        monsters[monsterCount].type = type; // 몬스터 타입 할당
        // 몬스터 HP를 타입에 따라 설정
        switch (type) {
            case 0: monsters[monsterCount].hp = 20; break;  // 달팽이 HP
            case 1: monsters[monsterCount].hp = 40; break;  // 도마뱀 HP
            case 2: monsters[monsterCount].hp = 80; break;  // 맹독 거미 HP
            case 3: monsters[monsterCount].hp = 500; break;  // 드라큘라 (히든) HP
            case 4: monsters[monsterCount].hp = 1000; break;  // 혼테일 (보스) HP
            default: monsters[monsterCount].hp = 20; break; // 기본 HP
        }
        monsterCount++; // 활성화된 몬스터 수 증가
    }
}

// 파이어볼/탄환 생성 함수
void spawnFireball(int x, int y, int dx, int dy, int is_monster_bullet, int damage) {
    for (int i = 0; i < MAX_FIREBALLS; i++) { // 파이어볼 배열을 순회
        if (!fireballs[i].active) { // 비활성화된 파이어볼 슬롯을 찾음
            fireballs[i].active = true; // 파이어볼 활성화
            fireballs[i].x = x; // 초기 X 위치 설정
            fireballs[i].y = y; // 초기 Y 위치 설정
            fireballs[i].dx = dx; // X 방향 설정
            fireballs[i].dy = dy; // Y 방향 설정
            fireballs[i].is_monster_bullet = is_monster_bullet; // 몬스터 탄환 여부 설정
            fireballs[i].damage = damage;  // 데미지 값 설정
            break; // 생성 후 루프 종료
        }
    }
}

// 메테오 스킬 함수 (플레이어 스킬)
void castMeteor() {
    if (strcmp(playerEmojis[currentEmoji], "🐉 ") != 0) return;  // 플레이어가 용일 때만 발동

    for (int i = 0; i < 10; i++) { // 총 10발의 메테오 낙하
        int mx = rand() % COL; // 맵 열 범위 내에서 랜덤 X 위치
        int my = 0; // 맵 상단에서 시작
        spawnFireball(mx, my, 0, 1, 0, 50); // 아래로 이동하는 파이어볼 (메테오) 생성, 50 데미지
    }
}

// 드래곤 브레스 스킬 함수 (플레이어 스킬)
void castDragonBreath(int px, int py, int last_dx, int last_dy, int is_monster_bullet) {
    // 플레이어 주변 3x3 영역의 오프셋 (마지막 이동 방향을 고려)
    int offsets[9][2] = {
        {-1, -1}, {0, -1}, {1, -1},
        {-1,  0}, {0,  0}, {1,  0},
        {-1,  1}, {0,  1}, {1,  1}
    };
    if (strcmp(playerEmojis[currentEmoji], "🐉 ") != 0) return;  // 플레이어가 용일 때만 발동

    for (int i = 0; i < 9; i++) {
        int fire_x = px + offsets[i][0] + last_dx; // 파이어볼 X 위치 계산
        int fire_y = py + offsets[i][1] + last_dy; // 파이어볼 Y 위치 계산
        spawnFireball(fire_x, fire_y, last_dx, last_dy, is_monster_bullet, 20); // 파이어볼 (드래곤 브레스) 생성, 20 데미지
    }
}

// 몬스터 이동 및 탄환 발사 함수 (추가)
void updateMonsters(int playerX, int playerY, char map[ROW][COL]) {
    for (int m = 0; m < monsterCount; m++) { // 모든 몬스터에 대해 반복
    if (!monsters[m].alive) { // 몬스터가 죽어있다면
        if (monsterRespawnTimer[m] > 0) { // 리젠 타이머가 남아있으면 감소
            monsterRespawnTimer[m]--;
        } else if (monsterRespawnTimer[m] == 0 && monsters[m].type <= 2) { // 타이머가 0이고 일반 몬스터(타입 0~2)라면 리젠
            monsters[m].x = monsterOriginX[m]; // 원래 위치로 복귀
            monsters[m].y = monsterOriginY[m];
            // 몬스터 리젠 후 체력 설정
            switch (monsters[m].type) {
                case 0: monsters[m].hp = 20; break;
                case 1: monsters[m].hp = 40; break;
                case 2: monsters[m].hp = 80; break;
                case 3: monsters[m].hp = 500; break; // 보스 몬스터는 리젠하지 않도록 되어 있으나, 혹시 모를 경우를 위해 포함
                case 4: monsters[m].hp = 1000; break; // 보스 몬스터는 리젠하지 않도록 되어 있으나, 혹시 모를 경우를 위해 포함
                default: monsters[m].hp = 20; break;
            }
            monsters[m].alive = 1; // 몬스터를 다시 살아있는 상태로
            monsters[m].move_counter = 0; // 카운터 초기화
            monsters[m].shoot_counter = 0; // 카운터 초기화
        }
        continue; // 다음 몬스터로 넘어감
    }

        // 몬스터 이동 처리
        monsters[m].move_counter++;
        if (monsters[m].move_counter >= MONSTER_MOVE_DELAY) { // 이동 딜레이가 충족되면
            monsters[m].move_counter = 0; // 카운터 초기화
            int dx = 0, dy = 0;
            // 플레이어 방향으로 이동 방향 설정
            if (monsters[m].x < playerX) dx = 1;
            else if (monsters[m].x > playerX) dx = -1;
            if (monsters[m].y < playerY) dy = 1;
            else if (monsters[m].y > playerY) dy = -1;

            int newX = monsters[m].x + dx; // 새로운 X 위치
            int newY = monsters[m].y + dy; // 새로운 Y 위치

            // 벽, 장애물, 플레이어 위치, 다른 몬스터와 충돌 체크
            if (newX >= 0 && newX < COL && newY >= 0 && newY < ROW &&
                map[newY][newX] != '1' && map[newY][newX] != '2' && // 벽('1')이나 장애물('2')이 아닌지 확인
                !(newX == playerX && newY == playerY)) { // 플레이어 위치가 아닌지 확인
                int can_move = 1; // 이동 가능 여부 플래그
                for (int k = 0; k < monsterCount; k++) { // 다른 몬스터와 충돌 체크
                    if (k != m && monsters[k].alive && monsters[k].x == newX && monsters[k].y == newY) {
                        can_move = 0; // 이동 불가능
                        break;
                    }
                }
                if (can_move) { // 이동 가능하다면
                    monsters[m].x = newX; // 몬스터 위치 업데이트
                    monsters[m].y = newY;
                }
            }
        }

        // 몬스터 탄환 발사 처리
        monsters[m].shoot_counter++;
        if (monsters[m].shoot_counter >= MONSTER_SHOOT_DELAY) { // 발사 딜레이가 충족되면
            monsters[m].shoot_counter = 0; // 카운터 초기화
            int dx = 0, dy = 0;
            // 플레이어 방향으로 탄환 발사 방향 설정
            if (monsters[m].x < playerX) dx = 1;
            else if (monsters[m].x > playerX) dx = -1;
            if (monsters[m].y < playerY) dy = 1;
            else if (monsters[m].y > playerY) dy = -1;
            if (dx != 0 || dy != 0) { // 방향이 유효하면
                int sx = monsters[m].x + dx; // 탄환 시작 X 위치
                int sy = monsters[m].y + dy; // 탄환 시작 Y 위치
                if (sx >= 0 && sx < COL && sy >= 0 && sy < ROW) { // 유효한 맵 범위 내라면
                    spawnFireball(sx, sy, dx, dy, 1, 10);  // 몬스터 탄환 생성, 10 데미지
                }
            }
        }
    }
}

// 파이어볼 업데이트 함수
void updateFireballs(char map[ROW][COL], int *playerHP, int *playerMaxHP, int playerX, int playerY) {
    
    for (int i = 0; i < MAX_FIREBALLS; i++) { // 모든 파이어볼에 대해 반복
        if (fireballs[i].active) { // 활성화된 파이어볼이라면
            int newX = fireballs[i].x + fireballs[i].dx; // 새로운 X 위치
            int newY = fireballs[i].y + fireballs[i].dy; // 새로운 Y 위치

            // 맵 경계를 벗어나거나 벽에 부딪히면 파이어볼 비활성화
            if (newX < 0 || newX >= COL || newY < 0 || newY >= ROW || map[newY][newX] == '1') {
                fireballs[i].active = 0;
            } else {
                // 플레이어의 파이어볼이 몬스터에 맞았는지 확인
                if (!fireballs[i].is_monster_bullet) { // 플레이어의 파이어볼인 경우
                    for (int m = 0; m < monsterCount; m++) { // 모든 몬스터에 대해 반복
                        if (monsters[m].alive && monsters[m].x == newX && monsters[m].y == newY) { // 몬스터와 충돌했다면
                            monsters[m].hp -= fireballs[i].damage;  // 파이어볼의 데미지만큼 몬스터 체력 감소
                            if (monsters[m].hp <= 0) { // 몬스터 체력이 0 이하면
                                monsters[m].alive = 0; // 몬스터 죽음 처리
                                monsterRespawnTimer[m] = MONSTER_RESPAWN_DELAY; // 리젠 타이머 설정
                                int type = monsters[m].type; // 죽은 몬스터의 타입 저장

                                // 퀘스트 1: 달팽이 (타입 0)
                                if (type == 0 && questAccepted[0] && !questCompleted[0]) {
                                    if (questKillCount[0] < 10) questKillCount[0]++; // 처치 수 증가
                                    if (questItemCount[0] < 5 && rand() % 100 < 50) questItemCount[0]++; // 50% 확률로 아이템 획득
                                    if (questKillCount[0] >= 10 && questItemCount[0] >= 5) {
                                        if(queststop <= 0){ // 메시지 중복 출력을 막기 위한 플래그
                                            printf("\n📜 [퀘스트 1] 목표 달성! NPC에게 돌아가세요.\n");
                                            usleep(1000000);
                                            queststop += 1;
                                        }
                                    }
                                }

                                // 퀘스트 2: 도마뱀 (타입 1)
                                if (type == 1 && questAccepted[1] && !questCompleted[1]) {
                                    if (questKillCount[1] < 10) questKillCount[1]++;
                                    if (questItemCount[1] < 5 && rand() % 100 < 50) questItemCount[1]++;
                                    if (questKillCount[1] >= 10 && questItemCount[1] >= 5) {
                                        if(queststop <= 1){
                                            printf("\n📜 [퀘스트 2] 목표 달성! NPC에게 돌아가세요.\n");
                                            usleep(1000000);
                                            queststop += 1;
                                        }
                                    }
                                }

                                // 퀘스트 3: 맹독 거미 (타입 2)
                                if (type == 2 && questAccepted[2] && !questCompleted[2]) {
                                    if (questKillCount[2] < 10) questKillCount[2]++;
                                    if (questItemCount[2] < 5 && rand() % 100 < 50) questItemCount[2]++;
                                    if (questKillCount[2] >= 10 && questItemCount[2] >= 5) {
                                        if(queststop <= 2){
                                            printf("\n📜 [퀘스트 3] 목표 달성! NPC에게 돌아가세요.\n");
                                            usleep(1000000);
                                            queststop += 1;
                                        }
                                    }
                                }

                                // 던전 3 몬스터 (맹독 거미) 처치 시, 19% 확률로 열쇠 드랍
                                if (type == 2 && rand() % 100 < 19 && !hasKey) {
                                    hasKey = 1; // 열쇠 획득
                                    printf("\n🗝️ 맹독 거미가 히든 던전의 열쇠를 떨어뜨렸습니다!\n");
                                    usleep(1500000);
                                }

                                // 퀘스트 4: 드라큘라 (타입 3)
                                if (type == 3 && questAccepted[3] && !questCompleted[3]) {
                                    questKillCount[3]++;
                                    questItemCount[3]++;
                                    if (questKillCount[3] >= 1 && questItemCount[3] >= 1) {
                                        printf("\n📜 [퀘스트 4] 목표 달성! NPC에게 돌아가세요.\n");
                                        usleep(1000000);
                                    }
                                }

                                // 퀘스트 5: 혼테일 (타입 4)
                                if (type == 4 && questAccepted[4] && !questCompleted[4]) {
                                    questKillCount[4]++;
                                    questItemCount[4]++;
                                    if (questKillCount[4] >= 1 && questItemCount[4] >= 1) {
                                        printf("\n📜 [퀘스트 5] 목표 달성! NPC에게 돌아가세요.\n");
                                        usleep(1500000);
                                    }
                                }

                                fireballs[i].active = 0; // 파이어볼 비활성화
                                goto skip_update; // 현재 파이어볼 업데이트 건너뛰고 다음 파이어볼로
                            }
                        }
                    }
                }

                // 몬스터 탄환이 플레이어에 맞았는지 확인
                if (fireballs[i].is_monster_bullet && newX == playerX && newY == playerY) {
                    
                //몬스터가 플레이어에게 주는 데미지
                    if (monsters[i].type == 0) 
                        *playerHP -= 20;  
                    if (monsters[i].type == 1)
                        *playerHP -= 25;
                    if (monsters[i].type == 2)
                        *playerHP -= 30;
                    if (monsters[i].type == 3)
                        *playerHP -= 40;
                    if (monsters[i].type == 4)
                        *playerHP -= 50;
                    
                    if (*playerHP < 0) *playerHP = 0; // 체력이 0 미만으로 내려가지 않게 보정
                    fireballs[i].active = 0; // 탄환 비활성화
                    goto skip_update; // 현재 탄환 업데이트 건너뛰고 다음 탄환으로
                }
                // 몬스터 탄환의 이동 속도 제어
                static int monsterBulletFrameCounter = 0; // 정적 변수로 프레임 카운터
                monsterBulletFrameCounter++;
                if (fireballs[i].is_monster_bullet) {
                    fireballs[i].move_counter++;
                    if (fireballs[i].move_counter % MONSTER_BULLET_MOVE_DELAY != 0) { // 딜레이가 충족되지 않으면 이동 건너뛰기
                        continue;
                    }
                }

                // 파이어볼/탄환 위치 갱신
                fireballs[i].x = newX;
                fireballs[i].y = newY;
            }
        }
        skip_update:; // goto 문을 위한 레이블
    }
}

// 터미널 원시 모드 비활성화 함수 (종료 시 원래대로 복구)
void disableRawMode() {
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios); // 원래 터미널 설정으로 복구
}

// 터미널 원시 모드 활성화 함수 (즉시 키 입력 처리 위함)
void enableRawMode() {
    tcgetattr(STDIN_FILENO, &orig_termios); // 현재 터미널 설정 백업
    atexit(disableRawMode); // 프로그램 종료 시 disableRawMode 함수 자동 호출 등록
    struct termios raw = orig_termios; // 백업된 설정을 복사
    raw.c_lflag &= ~(ECHO | ICANON); // ECHO (입력 문자 화면 출력) 및 ICANON (정규 모드, Enter 키 입력까지 버퍼링) 비활성화
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw); // 새로운 설정 적용 (버퍼 플러시 후)
}

// 비블로킹 방식으로 문자 하나를 읽는 함수
char getch_nonblock() {
    char c = 0;
    int flags = fcntl(STDIN_FILENO, F_GETFL, 0); // 현재 파일 디스크립터 플래그 가져오기
    fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK); // O_NONBLOCK 플래그 추가 (비블로킹 모드)
    read(STDIN_FILENO, &c, 1); // 문자 하나 읽기 (입력이 없으면 즉시 반환)
    fcntl(STDIN_FILENO, F_SETFL, flags); // 원래 플래그로 복구 (블로킹 모드)
    return c; // 읽은 문자 반환
}

// 블로킹 방식으로 문자 하나를 읽는 함수 (Enter를 기다리지 않음)
char getch() {
    char c;
    if (read(STDIN_FILENO, &c, 1) == 1) // 문자 하나를 읽고 성공하면
        return c; // 읽은 문자 반환
    else
        return 0; // 실패 시 0 반환
}

// 물약 상점 열기 함수
void openPotionShop(int* gold, int* potion1_hp, int* potion2_hp, int* potion3_hp) {
    char choice;
    while (1) {
        printf("\033[H\033[J"); // 화면 지우기 및 커서 홈으로 이동
        printf("\n---------- 🏥 물약 상점에 오신 것을 환영합니다! ----------\n");
        printf("\n");
        printf("            보유 골드: 💰 %dG\n", *gold);
        printf("\n");
        printf("            1. 하급 체력 물약 (💚 ) - 10G\n");
        printf("              - 체력 회복량 + 10            \n\n");
        printf("            2. 중급 체력 물약 (💙 ) - 30g\n");
        printf("              - 체력 회복량 + 30            \n\n");
        printf("            3. 상급 체력 물약 (💖 ) - 100g\n");
        printf("              - 체력 회복량 + 70            \n\n");
        printf("            4. 나가기\n");
        printf("\n");
        printf("----------------------------------------------------------\n");
        
        choice = getch(); // 사용자 입력 대기
        if (choice == 0x1b) { // ESC 키 입력 처리 (방향키 등의 복합 입력 방지)
            getch(); getch();
            continue;
        }

        if (choice == '1') { // 하급 물약 구매
            if (*gold >= 10) {
                *gold -= 10;
                (*potion1_hp)++;
                printf("💚 하급 체력 물약을 구매했습니다! (남은 골드: %dG)\n", *gold);
            } else {
                printf("❗ 골드가 부족합니다!\n");
            }
        } else if (choice == '2') { // 중급 물약 구매
            if (*gold >= 30) {
                *gold -= 30;
                (*potion2_hp)++;
                printf("💙 중급 체력 물약을 구매했습니다! (남은 골드: %dG)\n", *gold);
            } else {
                printf("❗ 골드가 부족합니다!\n");
            }
        } else if (choice == '3') { // 상급 물약 구매
            if (*gold >= 100) {
                *gold -= 100;
                (*potion3_hp)++;
                printf("💖 상급 체력 물약을 구매했습니다! (남은 골드: %dG)\n", *gold);
            } else {
                printf("❗ 골드가 부족합니다!\n");
            }
        } else if (choice == '4') { // 상점 나가기
            printf("상점을 나갑니다...\n");
            usleep(1000000); // 1초 대기
            break; // 루프 종료
        } else {
            printf("❗ 잘못된 입력입니다. 다시 선택해주세요.\n");
        }
        usleep(1000000); // 1초 대기
    }
}

// 카지노 게임 함수 (슬롯 머신)
void playCasino(int* gold) {
    int bet = 0; // 베팅 금액
    int num[3]; // 슬롯 머신 숫자 3개
    int reward = 0; // 누적 당첨금
    char ch; // 입력 문자

    if (*gold < 10) { // 최소 베팅 금액 미달 시
        printf("\n💸 최소 10G 이상 있어야 슬롯머신을 돌릴 수 있습니다!\n");
        printf("게임으로 돌아갑니다...\n");
        usleep(1000000);
        return; // 함수 종료
    }

    while (1) {
        if (*gold <= 0) { // 골드가 모두 소진되면
            printf("\n💸 골드가 모두 소진되어 카지노에서 퇴장합니다...\n");
            usleep(1000000);
            break; // 루프 종료
        }

        printf("\033[H\033[J"); // 화면 지우기
        printf("\n------------ 🎰 슬롯머신 게임에 오신 것을 환영합니다! --------------\n");
        printf("\n");
        printf("현재 골드: %dG\n", *gold);
        printf("누적 당첨금 : %dG\n", reward);
        printf("\n------------------------------------------------------------------\n");
        printf("배팅 금액을 입력하세요 (숫자 입력 후 Enter): ");
        fflush(stdout); // 출력 버퍼 비우기

        char buffer[10] = {0}; // 입력 버퍼
        int index = 0; // 버퍼 인덱스

        while (1) { // 베팅 금액 입력 루프
            ch = getch(); // 문자 하나 읽기
            if (ch == '\n' || ch == '\r' || ch == 13) break; // Enter 키 입력 시 종료
            if (ch >= '0' && ch <= '9' && index < 9) { // 숫자이고 버퍼 공간이 있다면
                buffer[index++] = ch; // 버퍼에 추가
                putchar(ch); // 화면에 에코 (입력 문자 표시)
                fflush(stdout);
            } else if ((ch == 127 || ch == 8) && index > 0) { // Backspace 키 입력 시
                index--; // 인덱스 감소
                buffer[index] = '\0'; // 버퍼에서 문자 제거
                printf("\b \b"); // 화면에서 문자 지우기
                fflush(stdout);
            }
        }
        buffer[index] = '\0'; // 문자열 종료 널 문자 추가
        printf("\n");

        bet = atoi(buffer); // 입력된 문자열을 정수로 변환
        if (bet <= 0) { // 0 이하 금액 베팅 시
            printf("❗ 0 이하의 금액은 배팅할 수 없습니다!\n");
            printf("❗ 과도한 도박은 몸에 해롭습니다.\n");
            usleep(1000000);
            continue; // 다시 베팅 금액 입력
        }
        if (bet > *gold) { // 보유 골드 초과 베팅 시
            printf("\n❗ 보유 골드를 초과한 금액입니다!\n");
            usleep(1000000);
            continue; // 다시 베팅 금액 입력
        }

        *gold -= bet; // 베팅 금액만큼 골드 감소
        srand(time(NULL)); // 난수 시드 설정 (현재 시간 기준)
        num[0] = rand() % 9 + 1; // 1부터 9까지 랜덤 숫자 생성
        num[1] = rand() % 9 + 1;
        num[2] = rand() % 9 + 1;

        printf("\n🎰 결과: [ %d ] [ %d ] [ %d ]\n", num[0], num[1], num[2]); // 결과 출력

        if (num[0] == 7 && num[1] == 7 && num[2] == 7) { // 잭팟 (777)
            int prize = bet * 777; // 777배 보상
            reward += prize; // 누적 당첨금 증가
            *gold += bet; // 베팅 금액은 돌려받음 (순수 이득은 prize - bet)
            printf("🎉 JACKPOT! 1등 당첨! 777배 누적! (이번 당첨금: %dG)\n", prize);
        } else if (num[0] == num[1] && num[1] == num[2]) { // 세 자리 모두 같음
            int prize = bet * 5; // 5배 보상
            reward += prize;
            *gold += bet;
            printf("✨ 2등! 5배 누적! (이번 당첨금: %dG)\n", prize);
        } else if (num[0] == num[1] || num[0] == num[2] || num[1] == num[2]) { // 두 자리 같음
            int prize = bet * 2; // 2배 보상
            reward += prize;
            *gold += bet;
            printf("👍 3등! 2배 누적! (이번 당첨금: %dG)\n", prize);
        } else { // 꽝
            int loss = (*gold > 10) ? (*gold / 10) : 1; // 현재 골드의 10% 또는 최소 1골드 추가 차감
            *gold -= loss;
            printf("💔 꽝입니다. 골드의 10%%(%dG) 추가 차감됩니다.\n", loss);
        }

        printf("현재 골드: %dG | 누적 당첨금: %dG\n", *gold, reward); // 현재 골드 및 누적 당첨금 출력
        printf("-----------------------------------------------------\n\n");
        printf("🎰 재시작 : 1 / 종료 : 0 \n");
        printf(">> ");
        fflush(stdout);

        char again_ch;
        while (1) { // 재시작/종료 선택 루프
            again_ch = getch();
            if (again_ch == '0') { // 0 입력 시 종료
                printf("\n카지노를 종료합니다...\n");
                if (reward > 0) { // 누적 당첨금이 있다면 지급
                    printf("🎁 누적 당첨금 %dG를 지급합니다!\n", reward);
                    *gold += reward;
                    reward = 0; // 누적 당첨금 초기화
                }
                usleep(1000000);
                return; // 함수 종료
            } else if (again_ch == '1') { // 1 입력 시 재시작
                break; // 재시작 루프로 이동
            } else {
                printf("\n❗ 잘못된 입력입니다. 0 또는 1 만 입력 가능합니다.\n");
                printf(">> ");
                fflush(stdout);
            }
        }
    }

    if (reward > 0) { // 게임 종료 후 남은 누적 당첨금이 있다면 지급
        printf("\n🎁 누적 당첨금 %dG를 지급합니다!\n", reward);
        *gold += reward;
    }
    printf("게임 종료 후 총 골드: %dG\n", *gold);
    usleep(1000000);
}

// 게임 상태 초기화 함수 (재시작용)
void resetGame(int *playerX, int *playerY, int *playerHP, int *playerMaxHP, char **currentMapName, char map[ROW][COL], char map_backup[ROW][COL]) {
    *playerX = 1; // 플레이어 X 위치 초기화
    *playerY = 18; // 플레이어 Y 위치 초기화
    *playerHP = 100; // 플레이어 HP 초기화
    *currentMapName = "마을"; // 현재 맵 이름을 "마을"로 설정
    memcpy(map, map_backup, sizeof(char) * ROW * COL); // 맵을 백업 맵으로 복구
    monsterCount = 0; // 몬스터 수 초기화
    for (int i = 0; i < MAX_FIREBALLS; i++) { // 모든 파이어볼 비활성화
        fireballs[i].active = 0;
    }
}

// 출력 사이의 대기 시간 (초)
#define STORY_DELAY 2

// =================================================================
// ==================== ASCII Art 삽화 데이터 =======================
// =================================================================
// 용 보스 (Horntail) ASCII 아트 배열
const char* dragonBoss[] = {
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡅⠀⠀⠀⢀⡇⠀⠀⢀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⢀⠄⢀⣼⠃⡰⢀⡞⡠⠁⠀⡠⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠂⠐⢠⢞⡤⡚⣰⣿⢏⣼⡷⣿⢋⣠⠖⢉⠀⡀⠄⠂⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⢈⠀⠂⢄⢁⡸⢠⡿⣮⢮⣾⣿⢿⣟⣽⣟⣷⣟⣡⣶⡵⢊⣁⠤⠔⠂⠉⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠠⢀⠌⠢⠢⣰⢯⣟⣗⣯⡿⡫⡻⢮⡯⣾⣽⣯⢿⡿⣯⣾⣏⣁⢄⠀⡀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⢨⣾⣻⠶⣦⢵⣟⢳⢯⡻⡭⣻⣞⣯⢾⣟⣿⣻⣳⣽⣞⢿⣽⣟⣿⣮⠖⠦⠢⠤⡠⡀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⡀⣀⠠⠀⠄⠸⠫⡹⡫⢞⢿⢞⣷⣵⣟⢮⠞⡮⢮⡻⣝⣧⣿⣵⣷⣝⡿⣮⢯⡷⣿⢿⣷⣦⣄⡂⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⢰⠉⠀⡉⠉⠚⠢⠦⣄⠹⣌⣳⣱⣼⢞⣞⣺⡯⡻⢵⡿⣽⢭⡞⡶⢧⣝⣝⡞⣿⣽⣻⣟⣿⣻⡟⢿⡓⠢⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠳⢄⢀⠈⠠⠁⢢⡴⣾⢾⠽⡭⠛⢻⣿⣳⢯⣝⣗⣿⣻⢮⣏⣝⡳⣝⢮⡿⣞⣷⢿⣽⡿⣿⣿⡦⣍⠢⡄⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠁⠠⠁⠀⠻⡏⠁⠀⠀⠀⠀⠣⢻⡙⢯⣯⡊⠻⣦⡹⡚⢬⠑⠯⣚⢟⣿⣻⣟⣿⣿⣯⣿⡢⡑⠈⠁⠀⠈",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⠁⠀⠀⠀⠀⠂⠠⢀⠀⡀⠑⠄⢀⠙⠣⠄⡙⢆⠀⠠⠀⠠⡈⣷⢿⡿⣯⣿⣟⣿⣷⡌⠀⠀⠂⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡐⣠⣢⣾⣴⣷⣮⣖⣂⣠⣄⡠⠀⠄⢀⠀⡁⢀⠀⢲⣮⣿⢽⣿⣿⡿⣿⣛⢯⠻⣆⠌⠂⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠈⣴⢿⡿⣿⣿⢿⣿⣻⡿⣿⣿⣷⣶⣵⡤⠔⣠⣴⣴⣟⣿⣳⣿⢽⣿⣾⠟⣯⢣⠈⢧⠙⢄⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣻⢿⠯⠻⠛⠗⠿⠽⣷⣳⣯⣾⣞⡿⣿⢟⡷⣻⢮⣷⣿⢯⣿⢿⡟⠀⡷⡴⠃⠀⠁⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣻⡷⣄⡰⣠⣩⡵⣳⢽⡳⣷⣫⣞⢽⡞⣯⣻⡽⣻⣷⣿⡳⡿⡑⠀⠁⠇⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⡽⣯⣯⣫⢷⢵⡽⣾⡫⡻⣵⣷⣻⣽⣿⣿⣪⣿⣻⢷⢝⣿⣷⣷⣄⠀⠀⠐⠁⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣽⡷⣷⣻⣗⣿⣺⣷⣛⣿⣻⣞⣯⡷⣯⡿⣺⡧⣫⣗⣿⢿⣾⣻⣏⣴⣄⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⡙⠟⢿⡿⣽⣿⣺⢷⡯⣿⡽⠉⠛⡽⠸⣯⣿⡽⣾⡏⢻⣽⢷⣽⣟⣿⣿⡀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠈⠠⠚⣡⡿⣽⡿⣯⢿⣽⠛⠚⣀⢠⣀⣬⣿⣞⣿⣽⡧⠀⢻⣷⡿⢽⡋⢻⣧⠀⠀⠀⠀⠀",
"⠀⢀⠀⠀⠀⠀⠀⣀⣀⣱⣢⣿⣿⣶⣾⣵⣿⣿⣻⡿⣿⣭⣟⣷⣯⣿⣻⡾⣷⢿⣟⣿⠇⠀⣽⣇⣴⠂⠋⡸⠃⠀⠀⠀⠀⠀",
"⠀⠀⠢⠠⣄⠀⠉⢦⡀⢸⣺⣶⣿⣿⣟⣿⣽⢯⡿⣿⣽⣟⣿⣻⡿⣾⡽⣗⡿⣾⣽⣻⠏⠀⠠⠈⠉⠀⠀⠠⠀⠀⢀⠀⠀⠀⠀",
"⣈⠁⠓⠶⣤⣙⣳⣦⣿⡿⣟⣿⡺⣾⣝⣿⢾⣟⣿⣳⣿⣽⢷⣟⣿⣞⣿⡽⣿⢾⣯⡿⠽⠏⠁⠀⠀⠀⠀⠂⠀⠀⠀⠀⠀⠂⠀⠀⠀⠀",
"⠉⠙⠳⠶⣶⣽⣿⢾⣷⢯⡿⣞⣿⣻⣾⡽⣯⠋⢁⣉⣨⣍⣯⡻⣾⣽⡏⠉⠉⠉⠁⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠠⡠⢬⢿⣿⣿⣻⣟⣽⡿⣯⣿⣿⣿⣿⣟⡿⣻⣯⡿⣺⢾⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⣰⣿⣯⣿⣻⡿⠝⠛⠝⠁⠙⠚⠛⡾⣷⡸⣿⡞⢝⣿⢿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠁⢍⣷⢿⣮⢿⣧⠀⠀⠀⠀⠀⠀⠈⠀⠙⠀⠃⠀⠀⠈⠻⢿⣷⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⡐⢹⣟⣾⢯⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡿⠛⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠻⣟⣯⣿⣻⣷⣦⣤⣶⣟⣶⣷⣵⣶⡷⣶⣥⣤⣀⣛⠾⣿⡾⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠹⡏⠿⣽⢿⣿⣻⣿⣽⣷⣿⣽⣿⣻⣟⣿⣿⣿⣿⣯⡽⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠉⠢⣄⡈⠀⠈⠑⠌⠙⠒⠤⠀⠀⠀⠀⠀⠀⠀⠀⠉⠚⢿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣶⣤⣄⣈⣒⣤⡈⢢⡄⠀⢄⠀⠀⠀⠀⠀⠈⣿⣿⡏⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠻⣯⡿⣽⣻⢷⢿⣷⣤⣳⣔⣤⣢⣄⣶⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣀⣄⣿⣿⢷⣟⡿⣾⣽⣫⣯⢿⣽⣟⣿⣽⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢀⣄⣨⣷⣿⣻⣟⣷⢿⣞⣷⣿⣳⣟⣿⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠤⠒⢋⡭⠝⣻⡯⠷⢛⠝⡼⠑⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠘⠈⠀⠀⠁⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ",

};

// 드래곤 전투 장면 ASCII 아트 배열
const char* dragonFight[] = {
"⠀⠀⠈⠄⡁⠂⠀⠈⠄⠡⢈⠀⠀⠡⢈⠐⠀⠀⠈⠄⡁⠂⠀⠀⠡⢈⠐⠀⠀⠡⢈⠐⠀⠀⠈⠄⡁⠂⠀⠀⠡",
"⡐⠠⢈⠐⠀⡁⠂⠌⡀⠁⢂⠐⠠⠁⠂⠈⡐⠠⢈⠐⠀⡁⠂⠄⡁⠂⢈⠐⠠⠁⠂⠈⡐⠠⢈⠐⠀⢁⠂⠄⡁⠂⢈⠐⠠⠁⠂⠈⡐⠠⢈⠐⠀⢁⠂⠄⡁",
"⠄⠁⢂⠀⡀⠄⠁⠂⠄⡀⠠⠈⠄⡁⢀⠀⠄⠁⢂⠀⡀⠄⠁⠂⠄⣀⠂⠌⠠⢁⠀⡀⠄⠁⢂⠀⡀⠠⠈⠐⡀⢀⠠⠈⠄⡁⢀⠀⠄⠁⢂⠀⡀⠠⠈⠔⡀",
"⠀⠀⢀⠂⡐⠀⠀⢈⠐⠠⢁⠀⠀⡐⠠⢈⠀⠀⢀⠂⡐⠀⠀⠠⠈⠄⡈⠀⠀⢂⠐⠠⠀⠀⢀⠂⠄⡁⠀⠀⡐⢀⠂⠀⠀⡐⠠⢈⠀⠀⢀⠂⠤⢁⠂⠀⡐",
"⠌⡐⠠⠀⠀⠡⠈⠄⡈⢠⠤⣌⣐⣀⠁⠀⠌⡐⠠⠀⠀⠡⠈⠄⡁⠀⠠⠁⠌⡀⠈⠀⠡⢈⣄⣈⣤⣴⣧⣶⣶⣶⣼⣤⣥⣤⣥⣤⣬⣴⣠⣈⣄⠠⢈⠐⡀",
"⠂⠀⢁⠂⠄⡁⠈⠐⣀⣂⣔⣠⣴⣼⣿⣿⣶⣦⣥⣂⡄⠁⠈⠐⡀⠂⠄⠁⠂⣐⣤⣶⣿⣟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠋⠍⡉⠀⠂⠄⠄",
"⢀⠀⠠⣌⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠷⠶⣤⣡⡈⢀⠘⡉⠄⠠⢁⠉⡙⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣯⣿⣦⣁⠂⠄⡀⠀⠌",
"⠂⠌⡐⢩⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠟⠧⣄⠂⠄⠡⠀⠀⠙⡆⠐⡀⠀⣄⢆⡰⣀⠰⡉⠌⠹⣿⣿⣿⣿⣿⣿⣿⡽⢯⡟⣿⣿⣿⣶⣤⢀⠁⠂",
"⠁⠀⠐⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠄⠈⠀⢈⠐⡀⣏⠈⡄⠡⢈⠐⠀⠁⠄⡁⠚⠧⣳⢥⡓⢤⠈⠀⡈⠻⣿⣿⣿⣿⣿⣿⣷⡹⢧⣿⠁⠂⠌⠀⠈⡐",
"⢂⠐⡈⣉⣹⣿⣿⣿⣿⣿⣿⣿⢿⡁⠌⠐⡀⢆⣴⣮⣴⣿⣲⡄⣃⠄⢈⠐⡀⠂⠄⠁⢂⢸⢣⣻⢆⡹⠄⠄⠡⠙⣿⣿⣿⡷⣏⠿⣿⣟⣾⡄⠁⢢⠐⠠⠀",
"⠄⢂⠐⣻⢛⡙⢻⡽⣎⠷⣿⣿⣿⡀⢀⠢⣽⣿⣿⣿⣿⣿⣿⡽⣆⡆⢀⠂⠄⡁⢀⢰⢸⣡⣾⣷⣾⣿⣻⣬⠐⡀⣿⣿⣿⡿⣭⠳⣍⢿⣿⣿⣎⢧⠈⠄⡁",
"⠀⠀⠀⡟⡼⢰⠜⢳⣎⢳⡹⣿⣿⣷⣄⢚⣿⣿⣿⡟⡉⠻⣿⣿⣿⣧⠀⠀⠀⡐⢀⣾⣻⣼⣿⣿⢿⣿⣿⣿⣧⣼⣿⣿⣿⢟⡲⡹⣌⢿⡽⡐⢯⢳⠀⠀⡐",
"⠌⠠⠁⣿⣕⢣⠎⡱⣊⢧⠳⣜⡿⣿⣿⣿⣿⣿⣿⣿⣄⠡⠘⠿⡏⡙⠷⢈⠐⠠⣼⠾⣿⣿⠉⠄⣨⠿⣿⣿⣿⣿⣿⣿⣏⡮⣕⠳⠙⠾⣷⠨⣇⢧⠈⡐⠀",
"⠌⠠⠁⣾⢯⢧⡛⢴⡩⢆⠳⣀⢋⣥⣿⣿⣿⣿⣿⣻⣇⢂⠡⡘⠃⠌⠂⢆⡈⠄⡁⠂⢿⠀⠌⠰⣽⣼⣶⣿⣿⣿⣿⣿⣟⣫⢆⠡⡙⡜⣩⠓⣌⣧⠐⠠⢁",
"⡀⢀⠐⣌⡟⢧⣻⢦⡱⣈⠓⢶⣿⣿⣿⣿⣿⣿⣿⣷⣿⣾⠠⢈⡐⡈⡈⡄⡈⠀⡄⢁⢢⠻⢛⠳⣯⢿⣿⣿⣿⣿⣿⣿⣿⣷⡎⠔⡱⡘⢤⢫⣟⡾⢀⠀⠂",
"⡐⢀⠂⡽⢾⡹⣌⢷⣻⢴⡩⣿⣿⣿⣿⣿⣿⣿⠿⣷⣎⣻⣷⠟⡻⠥⣉⠴⢡⠊⣴⠥⣂⠳⣼⠟⠻⠛⡛⢋⢻⣿⣿⣿⣿⣿⣿⠥⡱⣉⡾⢏⢛⡻⠀⠌⡀",
"⠐⠀⠂⣿⣌⡛⡜⢶⡹⢾⡽⣿⣿⣿⣿⣿⣿⡛⢦⢩⠙⢷⣦⡸⣔⣡⢆⡃⡈⣾⢉⠲⠼⡟⡇⠌⣡⢢⣵⣮⣷⣿⣿⣿⣿⣿⣿⣗⡈⠯⢛⢤⣣⢟⠀⢂⠐",
"⠠⢀⠐⣮⣟⠿⣼⣮⡱⣧⡁⢿⣿⣿⣿⣟⢹⣿⣦⢧⣙⢆⡛⢳⠦⣘⢳⣌⡈⡲⣧⢊⠔⣡⢘⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⡇⣮⣽⣢⣟⡾⢀⠂⠌",
"⡁⠂⠌⣿⣿⣿⡴⣯⡕⣣⡝⡁⢿⣿⣿⣿⣦⡻⣜⠧⣍⠮⣍⢣⠝⣌⣿⡧⡈⠿⣻⢷⣾⣶⠿⣛⣭⣶⡾⢟⢛⠻⣩⣿⣿⣿⡿⣝⡈⢭⡙⣷⢟⡿⠀⠌⡀",
"⠀⠀⢈⣿⣿⣿⣟⡷⢳⡜⡻⢶⡁⣟⠿⣿⣿⣿⣶⣯⣬⣳⣬⣧⣾⣿⡟⡰⡈⠳⡘⡒⢆⢎⡈⡈⡈⡈⡘⢆⣩⣶⣿⣿⣿⡛⡈⣴⢢⡞⣽⣏⣯⡶⠁⠀⡐",
"⢂⠐⠠⠭⡻⢿⣿⣿⣷⣭⡟⣮⢷⡁⡁⣬⣽⣛⠿⡿⢿⠿⡿⢟⡻⢉⡬⣑⢣⡈⡈⡈⡈⣌⡈⡈⣣⣶⣽⠾⢿⡛⢉⡈⡈⡈⡿⣬⢷⣿⡟⠿⠁⢂⠁⠂⠄",
"⠂⠌⠐⡀⠁⠬⢼⣻⣿⢷⣿⣵⣦⣍⣻⡁⡁⡁⡁⡁⡆⣙⡐⢣⣎⡈⡈⡈⡈⣇⡈⡈⣙⡈⡈⡈⡈⡈⡈⡈⡈⡈⣦⣽⠫⡞⣷⣽⣿⣛⣠⢀⠠⠀⠌⠐⡀",
"⠀⠀⠐⠠⠉⠄⠀⠠⠙⢋⠛⠳⣿⣼⣜⣯⢶⣽⣹⣋⣶⣥⡈⡈⡈⡈⡈⡈⡈⡈⡈⡈⡈⣋⢶⣏⣿⣿⣽⣶⢮⣭⣶⣿⣶⡙⢃⡀⢁⠈⡁⢂⠁⠀⠀⡐",
"⠌⠠⢁⠀⠁⠌⡀⢃⠹⢆⠎⡰⠏⢂⠋⢽⣩⡉⠟⣿⣿⣷⣿⣾⣍⣯⣴⣍⡶⣻⢿⣟⣯⣿⡿⠿⢚⠞⠹⣇⠈⠡⠒⡀⢊⠁⠉⠁⠌⡀⢂⠀⠀⠈⠄⠡⠀",
"⠈⠐⠠⠀⠄⠂⠐⢀⠂⠌⠠⠑⠈⠄⠠⢀⠀⠉⠛⡄⢉⠛⠛⠉⠄⢲⡹⠻⣿⣝⡚⠚⢉⠙⠢⠌⠠⠈⠋⡐⠊⠄⡐⠀⠂⠄⠠⢀⠂⠐⠠⠀⠄⡈⠀⠁⢂",
"⡀⢀⠠⠁⠌⡀⢀⠠⠈⠄⠡⢈⠀⠌⡐⠠⢀⠀⡐⢈⠒⡉⠒⡈⠘⠡⠐⡀⢈⠑⠢⢁⠈⡁⠐⡈⠄⡁⢂⠀⡁⢂⠐⡀⠀⠌⡐⠠⢀⠀⠠⢁⠂⠄⡀⢀⠂",
"⠐⡀⢂⠀⠀⡐⢀⠂⡁⠀⠐⠠⠈⠄⠀⠀⢂⠐⠠⠀⠀⠄⠡⢀⠁⠀⠐⡀⠂⠄⠀⠀⠂⠄⠡⠀⠀⠐⡀⠂⠄⠀⠐⠠⢁⠂⠀⠀⠂⠌⡐⠀⠀⠐⡀⠂⠄",
"⠁⠀⠠⢈⠐⡀⠀⠐⠠⠁⠌⠀⠁⠌⠠⢁⠀⢈⠠⠁⠌⡀⠁⠀⠌⠠⢁⠀⠁⠌⠠⢁⠈⠀⠡⠈⠄⡁⠀⠁⠌⠠⢁⠀⠀⠌⠠⢁⠈⠀⠠⠁⠌⡀⠀⠁⢂",
"⠠⢀⠐⠀⠂⠄⠠⠈⠄⠡⠈⠄⠠⠈⠐⠠⠀⠄⢂⠁⠂⠄⠠⠐⡈⠐⠠⠀⠄⡈⠐⠠⠀⠄⠠⠁⠂⠄⠠⠀⠌⠐⠠⠀⠄⡈⠐⠠⠀⠄⠠⠁⠂⠄⠠⢀⠂"
};

// 용 (플레이어 캐릭터) ASCII 아트 배열
const char* dragon[] ={
"⣿⣿⣿⣿⣿⣿⣶⣤⡀⡀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⡿⢟⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣅⡂⡀⠁⠈⢀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣷⢸⠹⣿⣿⣿⣿⣾⣦⣇⠢⠀⠄⠐⠈⠉⠙⠛⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⢡⡠⠀⠀⠂⢀⠙⢿⣿⣿⣿⣿⣿⣧⡑⠌⡙⠿⣿⣿⣿⣿⣷⡡⠀⡁⠈⠄⠁⡀⠂⢀⠈⢉⠙⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣷⡆⡐⠀⢀⠀⠄⠙⢿⣿⣿⣿⣿⣧⠡⠠⠀⠙⢿⣿⣿⣿⣿⣆⠐⠠⠀⠁⠄⡐⠀⠠⠀⡀⠂⠀⡀⠙⠻⠿⣿⣿⣿⣿⣿⣿",
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡌⠢⡀⡀⠀⢀⠀⠉⠿⣿⣿⣿⣧⢑⢈⠠⠀⠙⢿⣿⣿⣿⡌⡂⡂⠄⠀⠀⠅⡂⠠⠀⠐⢀⠀⠠⠀⠀⠈⠛⢿⣿⣿⣿",
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡁⠢⠐⡈⠀⠀⠀⠄⠈⠻⣿⣿⣇⠢⠀⢂⠠⠀⠙⢻⣿⣿⡰⢐⠐⠈⠀⠀⢀⠡⠂⠁⠀⠐⠀⠄⠈⠀⡀⠂⠙⢿⣿",
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠡⠡⠐⡈⢀⠂⢀⠀⢀⠈⢻⣿⡅⠅⠄⢀⠀⠄⠀⠙⢿⡮⡂⠌⠌⡀⠁⠀⠀⠈⠨⡀⠁⠀⠂⠈⢀⠀⠀⠈⠀⠙",
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠅⠂⡂⠅⠌⠄⢀⠄⠀⠀⠈⢇⠕⠠⠀⡀⠀⠄⠀⠀⢕⢐⠁⡂⠄⢁⠐⠀⠁⠀⡀⢑⠈⠀⠈⠀⠀⠄⠁⠈⠀",
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠡⠡⡂⠅⠅⠌⢂⠀⠂⡁⠀⡢⢑⠁⠄⠀⠀⠄⠀⢠⢃⠂⡂⢐⠀⠂⠠⠀⠄⠂⠀⠀⠨⠐⠀⠂⠀⠀⠄⠀⠄",
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⢿⠯⡸⠈⢔⠨⠠⠑⠀⠅⠐⢀⠀⡀⠀⠈⠀⢈⢀⠠⠨⠂⡀⡂⡐⠠⢀⠡⠐⠀⢀⠀⠀⠠⠀⠈⢂⠄⠈⠀⢀⠠",
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣯⠻⢇⠫⡸⠨⠠⡑⢐⠨⢀⠡⠈⢀⠠⠈⠀⠀⡀⠨⢐⠨⢀⠐⠐⡈⠄⠂⠠⠀⠂⡀⠀⠠⠀⠀⠀⢀⠀⠀⠠⠐⠀⠂⡁⢀⠀",
"⣿⣿⣿⣿⣿⣿⣿⣿⢿⡟⠽⡉⢑⠈⠠⡐⡕⡁⠢⡱⠀⢂⠐⡀⠄⠈⢀⠠⠈⡐⢀⠡⢀⠐⢀⠨⠀⠄⠐⠈⠀⠐⠀⠀⠀⠄⠀⠈⠀⠀⠀⠀⠀⠀⡀⠈⠄⡀⠀⠄",
"⣿⣿⣿⣿⣿⣿⢿⡉⠣⠠⠁⠄⠂⠌⡊⡢⡑⡀⠅⡇⠀⠂⢂⠐⡈⠠⠀⡀⠂⢀⠠⠀⠀⠄⠀⡀⠄⠀⠄⠀⠄⠀⠠⠐⠀⠀⠠⠀⢂⠠⡈⢄⢐⠀⠀⡀⠐⠠⠀⠀",
"⣿⣿⣿⣿⡿⡝⢒⠠⠡⢁⠈⠠⠈⣂⠐⢐⢐⠀⢂⠅⢀⠀⠂⠀⢄⠇⠀⢀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠄⠀⠄⢀⠀⠀⠠⡑⡅⡣⡱⡰⣌⢢⠢⡡⡁⡂⡂⡁⠡⠀",
"⣿⣿⡿⡣⠃⠂⢄⠅⢂⠌⡌⠔⢈⠦⡈⢐⠠⠐⡈⠀⠀⠀⢈⢢⠅⠀⠀⠀⡀⠂⠀⠁⠀⠀⠁⠠⠀⢀⠀⠂⢀⠠⠀⠁⡈⡊⡺⡸⣪⢪⡪⣪⢪⢢⢢⠡⡂⡡⠁⠀",
"⣿⣿⡿⡁⢂⠡⠁⠅⢔⠡⠊⡀⠂⢀⠑⠹⡐⡀⢀⠂⠐⠀⢔⢀⠊⠀⠀⠂⠁⠀⠀⠈⠀⠈⡀⢈⠀⠀⠀⠠⠐⠀⠀⠄⠀⠀⠊⠌⠜⡌⣇⠯⣪⡺⡢⡱⡱⡐⡐⡁",
"⡿⡛⠠⢐⢄⠢⢑⠉⠄⠂⠀⡀⠠⠀⠀⢅⠨⣂⠠⠀⢁⠨⠈⠀⢀⠀⠂⢀⠐⠀⠀⠠⠀⢁⢮⡲⡅⢅⠂⠀⠠⠀⢁⠀⡁⠀⠄⠁⠡⠸⡘⢝⡲⣕⡇⣏⢮⢊⢆⠅",
"⠃⡰⠡⠡⠐⢈⠀⠄⣰⣴⢤⡠⢀⠐⠀⡈⠔⠐⠄⠌⢀⠃⠁⡈⠀⠀⢀⠐⡀⠁⠀⠀⠀⠢⡩⢣⠣⡑⠨⠐⠀⠈⡀⢀⠐⠀⠀⠐⠈⠢⡀⠄⡫⢮⡺⡸⡜⡎⡆⡣",
"⡃⡂⢁⢈⢰⡀⡂⣽⣿⣿⣟⡯⣇⠄⣂⣄⡘⡀⠅⠅⡂⠀⠂⠀⠀⠀⠠⠐⠀⠈⠀⡀⠂⠈⠄⠅⠢⠨⠠⢁⠐⠀⠀⡀⢂⠁⠄⠀⠀⠂⢡⢐⢐⣕⣏⣗⡝⡎⡪⠢",
"⢇⠂⡐⡔⡅⡇⣇⢷⣻⡽⣯⡻⡜⡎⣿⣿⣽⣢⠠⠑⠄⠄⡀⣂⢢⢂⡢⠠⡀⠂⠀⡀⢀⠀⠁⠈⠄⢁⠐⠀⢀⠐⠀⠐⡀⠂⠄⢁⠐⠠⢊⢌⡼⡺⣜⣖⢣⠣⠣⡡",
"⢌⢎⢜⢜⢵⢱⡹⣺⢝⢵⢹⢸⠪⡳⣻⣺⢪⡣⠅⠂⡜⣜⢜⢮⠷⡯⡣⠢⠡⢀⠐⢀⠊⠀⠐⠈⠀⠀⠀⠂⡀⡢⣵⣗⢝⢌⢄⢐⢥⢏⡮⡯⣫⢺┥⇇⠣⡱⡘",
"⡨⠊⢜⠘⠜⠮⢮⢺⡪⣧⡣⡣⢣⡱⡜⡜⣜⢜⡼⣬⣨⢊⣆⣇⣇⢕⢅⠊⠜⢈⠠⠐⡀⠤⠌⢄⠄⢂⢀⢄⠡⢄⠏⡮⠪⡪⣔⣕⡧⡯⣛⠮⡋⡜⡌⢎⠢⡃⡃⠔",
"⠅⠌⢄⠝⢜⢌⢆⢇⠕⢕⠧⡫⡳⡹⡽⣕⢾⣝⢿⢽⣞⡳⡹⡝⡞⡕⡕⢕⠡⡠⡸⡳⣔⣔⣔⢄⣄⢦⣲⣳⣪⡲⣼⡺⣝⢞⢗⡓⡍⡎⡎⡇⡇⡣⡣⠃⠕⢐⠠⢁",
"⠌⢌⠢⢘⠐⢕⢕⢕⠝⢎⢎⢞⢎⢺⢸⢸⢜⢎⢯⢮⢮⣺⢜⡪⡢⣕⣜⢼⡪⣖⡯⡗⡗⣗⢝⢗⢽⢳⢵⣣⣳⢹⢜⢎⢎⢇⡇⡕⡕⡝⢘⠌⡎⡢⠂⠅⡡⢂⢊⢀",
"⠠⡡⠨⡠⢑⢐⢐⢈⠊⡢⡑⢅⢇⢇⡃⡇⡇⢧⢣⡣⡣⡋⡗⡝⡝⡞⣎⢧⡫⡮⢮⡫⡝⡎⡧⡫⡑⢕⢑⢒⣂⢇⢥⢳⠱⡱⢨⢊⠊⡔⡱⡘⠈⡀⡌⠌⠔⠁⡂⠁",
"⠁⠂⡁⡐⠠⠑⡐⢄⠨⠠⠈⢆⢊⠢⡃⢇⢔⢅⠥⢱⢱⠑⢕⢱⠨⡌⡌⠜⢌⠪⡢⣂⢣⠱⠑⠌⡎⡢⡪⡱⡐⠅⠣⢡⡐⢌⢠⢐⠪⢈⠂⠢⢑⠑⠨⠀⠅⠂⠔⠈",
"⠀⠡⠐⠀⠡⢂⠨⢀⠐⠨⢈⠠⢂⠑⡑⠄⢅⠣⡡⡂⠡⠡⡑⠔⣅⢢⢡⢡⠡⡊⡒⢌⢂⢕⢕⢹⢘⠜⢌⠆⠆⢎⠪⠡⢊⠂⠢⠨⡐⠔⠨⠊⡀⠄⠅⡁⢈⠀⡂⠡",
"⡊⡀⠂⠐⡀⠐⠨⠠⡈⠌⡀⢂⠁⠔⠈⠌⡐⢀⠂⠌⡑⠅⡂⠑⠄⠌⡈⢌⢌⠢⠊⠒⠐⡁⢂⠐⠄⠅⠡⠈⠌⠠⠀⠡⠠⠨⠨⠈⡀⡂⠅⡢⠂⢁⠡⢈⠀⡐⠀⠂",
"⣧⠐⢈⢀⠠⠈⠠⠁⠢⡀⡂⠄⢂⢁⠀⠁⠐⠠⢀⠂⠠⠡⠨⠈⠄⠅⠈⠠⠀⡈⠠⠁⡁⠄⠂⠌⡐⠠⠡⢑⢈⠂⡊⠌⠨⠈⠄⠡⠀⡀⠂⠠⠀⠄⠂⠀⠄⠠⠈⡀",
"⣿⡄⠐⠠⢀⠂⠐⠀⠐⠀⠂⡁⠂⠄⠊⠠⠡⠈⠀⡈⠨⠀⡈⠈⡈⠨⢈⢐⠀⠂⠂⢁⠐⠀⠁⠠⠀⠐⠀⠀⠀⡀⢀⠀⢁⠠⠈⠀⠅⠀⠂⠡⢀⠐⡀⠂⠌⠀⠄⠀",
};

// 총 (무기) ASCII 아트 배열 (사용되지는 않음, 추후 기능 추가용인 듯)
const char* gun[] ={
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡄⣄⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢢⢁⢀⢦⢢⢦⢦⢠⡠⡢⠠⡀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⣤⣳⠋⠉⠈⠅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⡂⣪⢺⠨⠢⠱⢱⠑⠕⠠⠀⠀⠈⠈⠂⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⡐⡜⣜⢞⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⢄⢂⢢⠲⡝⡎⡇⡍⡊⢎⡘⡬⠨⠈⠄⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⢀⢢⢱⢱⢽⣵⢱⠑⠄⠄⢄⠀⠀⠀⢀⠠⠠⠀⡀⠢⠨⡂⡇⡳⠱⡡⣑⢅⠑⢜⢌⢖⡜⡵⡡⢱⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠠⡐⣔⢵⡱⣝⡽⣺⡳⡥⡡⡱⡠⡡⡑⡐⡐⠄⢕⠔⢌⢊⢊⢌⡖⣜⡮⣞⡮⣪⡪⣳⢳⢵⢕⡧⡣⡪⡇⡄⡀⠀⠀⠀",
"⠀⠀⠀⠀⢈⢢⢕⢎⡮⣳⡻⣺⡪⡣⡫⣞⡷⣵⢵⢵⣕⣕⢼⢬⣠⢱⠱⡕⣗⣽⣞⢯⣪⢓⠫⠫⡫⡕⢵⢕⡯⣞⢵⡸⡸⡠⠑⠄⠀⠀",
"⠀⠀⠀⠀⡐⡱⡵⣏⣞⢧⢏⡗⡵⣝⡽⡽⣝⢽⣻⢽⢾⢾⣽⣵⣳⣯⢗⣝⢵⢗⡗⡵⡁⠂⠅⢅⢑⢝⢕⡇⡏⡗⡕⠝⡎⡎⡀⠨⠀⠀",
"⠀⠀⠀⣀⢢⡫⣗⢕⢇⢗⢽⢱⢱⢪⢪⢫⢪⢪⢪⢹⢹⢽⡽⣯⡷⣿⣝⢮⡫⣞⢌⠇⠆⠀⠀⠀⠂⡇⠂⠑⠐⠘⢔⠇⠈⠪⡆⡂⠀⠀",
"⠀⠀⢀⢚⢜⢜⢮⡳⣣⢫⢗⢕⢕⢕⠕⡕⡕⡕⡕⣕⢽⢽⣻⢿⣝⡷⡹⡸⣏⢎⠎⣜⠄⠀⠀⠀⠀⡇⠀⠀⠀⠀⠂⢯⠀⠀⠀⠀⠀⠀",
"⠀⠀⠐⡕⡕⣽⡝⡎⡮⡺⣕⢕⢕⢕⢕⢕⢱⠱⠑⡅⡯⣻⢝⣗⡷⡽⡘⠾⣕⢇⢳⢯⣪⠢⡀⠀⢀⢃⢀⢀⠀⠀⠈⠈⠀⠀⠀⠀⠀⠀",
"⠀⠀⢰⢱⢱⡳⡝⡜⡜⣜⢮⡠⣇⢇⠇⠃⠁⠠⡱⣸⢝⣞⣧⢻⣞⢿⡽⣵⢨⡂⡀⠁⠋⠳⠱⠵⣔⡵⡕⢍⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⢀⢪⢢⠱⡸⡕⢕⢕⢕⢵⢝⢜⠜⠀⠀⠀⠦⢮⡇⣯⣾⢯⣳⢧⣷⡻⡚⠳⡳⣌⢆⠄⠀⠨⠈⠁⠀⢝⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⢰⠱⡑⡑⡽⡸⡰⡱⡱⡱⣝⢎⠎⠀⠀⠌⣝⢜⣽⣽⣻⣽⣺⢽⡪⡀⢠⢠⢀⢱⢫⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠐⡜⢌⠪⡪⡺⡸⡸⡸⡸⡸⡸⣕⢇⠀⠠⠑⣕⢝⣞⣯⢻⡗⠓⠳⠙⠮⠓⠉⠐⢀⢏⠗⣟⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠨⡘⠔⠕⢌⠪⡳⡝⡼⣸⢸⡸⣸⡲⣄⠀⢠⢳⢏⢾⡇⡗⡕⠀⠀⠀⠀⠀⠀⠀⠈⠘⠁⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠨⡪⠈⠈⠀⠑⢍⢷⣣⠃⡗⠁⠀⠈⠘⠕⠦⣸⢹⢮⡻⡜⡌⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⡇⠀⠀⠀⠀⠀⠙⡮⡄⠅⠀⠀⠀⠀⠀⠀⠀⠈⠫⣞⣗⡕⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠱⠀⠀⠀⠀⠀⠀⠈⢗⡅⠀⠀⠀⠀⠀⠀⠀⠀⠁⠙⢮⣗⡇⡇⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠁⠠⠡⡁⠢⢐⠠⡈⡚⢦⡀⠀⠀⠀⠀⠀⠀⠀⠄⠅⠓⢏⢯⢧⢧⢢⠐⠄⢕⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⢀⠀⠌⠢⠨⡈⠢⡑⡐⢌⠢⡁⡃⡂⠀⠀⠀⠀⠀⠀⠡⢑⢐⠐⡔⠕⠍⡌⢎⢎⢆⢅⠐⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠈⠀⠈⠐⠌⠂⠂⠅⠅⠣⠱⡱⣌⡆⡄⠅⠅⡀⠀⠀⠀⠀⠑⠈⠈⠀⠈⢄⠅⢕⢕⢕⢐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠈⠂⠁⠁⠀⠀⠀⠀⠀⢁⠃⡋⣟⢕⢇⢗⢦⠂⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠐⠁⡇⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⠐⠑⠉⠣⡇⡅⡕⡤⣀⠀⠀⠀⠀⠀⠀⠀⠀⡀⣔⢼⠱⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠘⠚⠶⠲⢔⢆⢗⠕⠕⠁⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
};

// 여의주 ASCII 아트 배열
const char* Orb[] = {

"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡤⣔⡲⢮⡹⣍⢏⡗⣳⢲⡤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⣊⢏⠶⣡⢛⢦⠳⡜⣎⠞⣥⡓⡞⣭⣛⠶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⢫⠴⡉⢌⢢⠱⣍⢲⡹⡜⣬⢛⡴⡹⣜⡱⣎⢟⡼⣳⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⢀⡞⡥⣓⠢⣉⠆⡎⡵⣊⢧⡱⣙⢦⣋⠶⡱⢎⡵⢪⢏⡾⣱⢻⣄⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⡜⢮⡱⢎⡵⢊⡼⢱⡱⡍⢶⡱⣍⠶⣩⢞⡱⢫⡼⣙⢮⡵⣫⢗⡾⡄⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⢰⣋⢧⠳⣍⠶⣩⠞⡱⢎⡝⢦⠳⣬⢳⡱⢎⡝⣣⠞⣥⢳⡺⣵⢫⡞⣷⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⢸⡭⢎⡳⣬⠳⣥⢫⡕⣫⡜⣣⣛⠴⣣⡝⡺⡜⣥⠻⣜⣣⠷⣭⢳⣻⣼⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⢸⢧⢫⡵⣊⠷⣬⠳⡼⣱⢚⡵⢪⡝⢶⡩⢗⡹⡼⣙⠾⣼⡹⣎⣯⢗⡾⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠘⣏⢷⣚⡭⡞⣥⡛⢶⣙⢮⡜⢧⡝⡮⢵⣋⢷⡹⣭⣛⢶⣹⢳⡮⣟⡞⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠹⣎⢷⡳⣝⢶⣹⢣⣏⢶⡹⢞⡼⣙⢧⡝⣮⢳⢧⣛⣮⢽⣳⢻⡼⠁⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠛⣮⡳⣝⣮⢳⢯⡜⣮⢳⣏⢾⣙⢮⣝⢮⣛⡮⢷⣚⣯⠾⡽⠁⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠽⣳⢞⡽⣮⣝⢮⡗⣮⡳⣽⣚⣮⢯⣳⢟⣯⠽⣮⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠺⢽⣖⢯⣳⢯⣳⡽⢧⣟⢮⡟⣵⣻⠞⡋⠄⣀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠂⠌⠋⠓⠯⠳⠿⠽⠚⠛⢚⠡⠃⠜⠀⠃⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"                                                              "
};

// 부서진 여의주 ASCII 아트 배열
const char* brokenOrb[] = {
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⡀⠀⠀⠀⣠⣀⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡤⢾⡹⢭⣫⠽⣄⠀⠀⣽⣿⡼⣹⢛⡶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡞⢧⡉⢧⡹⢳⡬⣛⢾⡀⠰⣿⡽⣷⢭⣛⡼⢳⣻⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⣠⡞⢧⡙⢤⡘⡶⣙⠧⡞⣭⢞⡇⠀⠸⣿⣽⡮⣵⣋⢷⡹⣞⢿⣄⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⣠⢟⡼⢣⡜⣦⢛⡵⢭⣚⠽⣲⠭⡇⠀⠀⣿⣞⣷⢣⣞⣣⢟⡼⣏⡿⣦⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⢠⡟⣎⡒⢯⡜⣖⣫⡜⡳⢎⣛⡖⢯⡇⠀⠀⣿⣞⣯⢳⢎⣧⢻⡼⣫⣽⣻⡄⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⢸⣝⡲⡝⡧⢞⠶⣱⠞⣭⣛⡼⣚⡳⡆⠀⠀⣿⣞⣯⣏⡾⣜⣧⣛⡷⣯⢷⡗⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⡿⣜⣧⣿⣾⢯⣿⣾⣿⣶⣿⣾⣷⡿⠃⠀⠀⠷⠛⠻⠿⠟⠿⠿⢿⣿⣿⡿⠿⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠙⠛⠛⠳⠛⠉⠁⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣠⣄⣀⣀⣀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⣀⣠⣤⡴⢶⣺⢻⢭⡛⣟⡻⣛⡟⡇⠀⠀⣿⣿⣏⠷⣭⢯⣝⢯⣟⡿⣷⡄⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⣟⡳⢮⡝⣧⢳⡏⣞⡹⢶⡹⣵⣚⡇⠀⠀⣿⣽⢎⡿⣜⣳⣞⣻⢾⣽⣳⠃⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠘⣟⣯⠾⣵⢫⡞⣵⢫⢷⡹⣖⡽⡆⠀⢰⣿⣽⡺⣵⣫⣞⡾⣽⢯⣞⠃⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠘⢯⣟⣾⢳⣻⣼⢫⣞⡵⣏⣾⠇⠀⣾⢯⣷⣻⣵⣻⢾⡽⣯⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠾⣯⡷⣯⣟⣾⣳⡽⡎⠀⢰⣿⣟⣾⣳⢯⣟⣯⠟⠋⢀⠀⡀⠀⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠐⢠⠛⠳⠿⣞⣷⡿⠁⡄⢻⣿⡾⣳⠿⢛⠩⢂⠜⡈⠆⠒⢀⠁⠀⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠁⠀⠀⠀⠁⠀⠁⠀⠐⠀⠐⠈⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"                                                              "
};

// ASCII 아트를 출력하는 함수
void printArt(const char* art[], int lineCount) {
    for (int i = 0; i < lineCount; i++) {
        // art 배열의 각 문자열이 비어있지 않은 경우에만 출력
        if (art[i] && strlen(art[i]) > 0) {
            printf("%s\n", art[i]);
        }
    }
}

// 스토리 재생 함수 (구조체 사용 안함)
void playStory(const char** arts[], const int art_lines[], const char* texts[], int frameCount) {
    struct termios oldt, newt;
    // 키 입력이 바로 반영되도록 터미널 설정 변경
    tcgetattr(STDIN_FILENO, &oldt); // 현재 터미널 설정 가져오기
    newt = oldt; // 현재 설정 복사
    newt.c_lflag &= ~(ICANON | ECHO); // 정규(ICANON) 모드 및 에코(ECHO) 비활성화
    tcsetattr(STDIN_FILENO, TCSANOW, &newt); // 새 설정 적용

    for (int i = 0; i < frameCount; i++) {
        // 1. 화면 전체를 지운다.
        printf("\033[2J");
        
        // 2. 커서를 맨 위(1,1)로 옮긴다.
        printf("\033[1;1H");

        // 3. 현재 프레임의 삽화를 출력한다.
        if (arts[i] != NULL) { // 삽화가 있는 경우
            printArt(arts[i], art_lines[i]); // 삽화 출력
            printf("\n"); // 삽화와 대사 상자 사이에 한 줄 공백 추가
        } else { // 삽화가 없는 경우
            // 대사를 화면 중앙에 표시하기 위해 커서 이동
            printf("\033[11;1H"); // 11행 1열로 커서 이동 (대략 중앙)
        }

        // 4. 대사 상자를 그린다.
        printf(" %-75s \n", texts[i]); // 대사 출력 (75칸 왼쪽 정렬)

        
        // 5. 출력 버퍼를 비워 화면에 즉시 표시
        fflush(stdout);
        
        // 6. 다음 장면으로 넘어가기 전 잠시 대기
        sleep(STORY_DELAY); // 정의된 STORY_DELAY 만큼 대기
    }
    
    // 마지막에 사용자 입력 대기
    printf("\n(계속하려면 엔터를 눌러주세요)");
    fflush(stdout);
    // 버퍼에 남아있을 수 있는 문자를 비우고 입력을 기다림
    while(getchar() != '\n' && getchar() != EOF); // Enter 키가 눌리거나 파일 끝에 도달할 때까지 버퍼 비우기
    getchar(); // 최종적으로 Enter 키 입력 대기

    // 터미널 설정을 원래대로 복구
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt); // 원래 설정으로 복구
}

int main(void) {

    // --- 오프닝 스토리 데이터 ---
    const char** intro_arts[] = { // 삽화 배열
        dragon, dragon, dragon, NULL, dragonBoss, dragonBoss, dragonBoss, dragonBoss,
        dragonFight, dragonFight, dragonFight, dragonBoss, NULL, NULL, NULL
    };
    const int intro_art_lines[] = { // 각 삽화의 라인 수 배열
        sizeof(dragon)/sizeof(dragon[0]), sizeof(dragon)/sizeof(dragon[0]), sizeof(dragon)/sizeof(dragon[0]), 0, // NULL 삽화는 0 라인
        sizeof(dragonBoss)/sizeof(dragonBoss[0]), sizeof(dragonBoss)/sizeof(dragonBoss[0]), sizeof(dragonBoss)/sizeof(dragonBoss[0]), sizeof(dragonBoss)/sizeof(dragonBoss[0]),
        sizeof(dragonFight)/sizeof(dragonFight[0]), sizeof(dragonFight)/sizeof(dragonFight[0]), sizeof(dragonFight)/sizeof(dragonFight[0]),
        sizeof(dragonBoss)/sizeof(dragonBoss[0]), 0, 0, 0
    };
    const char* intro_texts[] = { // 각 장면에 대한 텍스트 대사
        "먼 옛날, 드래곤들이 평화롭게 살아가는 천공의 둥지가 있었다.",
        "그곳은 외부의 간섭 없이 드래곤들이 알을 낳고 키우는 신성한 장소였다.",
        "그곳에는 아직 어린 드래곤 곤과 그의 어미, 그리고 곧 태어날 동생들의 알이 있었다.",
        "그러던 어느날...",
        "오랜잠에서 깨어난 고대의 파멸자 '혼테일'이 나타났다.",
        "그는 끝없는 허기와 탐욕으로 먹잇감을 찾아 세상을 돌아다녔다.",
        "그의 발길이 닿는 곳마다 생명은 사라지고, 폐허만이 남았다.",
        "그러다 결국... 그는 천공의 둥지를 발견했다.",
        "어미 드래곤: “곤, 숨어있어라.. 절대 움직이면 안 돼”",
        "어미 드래곤은 곤에게 마지막 당부를 남기고 혼테일과 맞서 싸웠다.",
        "하지만 어미드래곤과 혼테일의 힘의 차이는 너무컸고, 어미드래곤은 쓰러졌다.",
        "혼테일은 둥지 안의 아직 부화하지 못한 알들을 먹어치운 후 떠났다.",
        "그 모든 걸 지켜봐야만 했던 곤은, 조용히 숨을 죽인 채 몸을 떨었다.",
        "모든 것이 무너진 그 순간, 작은 드래곤 곤의 마음 속엔 복수의 불씨가 피어올랐다.",
        "그리하여… 어린 드래곤의 복수의 여정이 시작되었다.",
    };
    int intro_frameCount = sizeof(intro_texts) / sizeof(intro_texts[0]); // 스토리 프레임 개수
                                     // --- 스토리 재생 ---
    
    sleep(1); // 1초 대기
    playStory(intro_arts, intro_art_lines, intro_texts, intro_frameCount); // 오프닝 스토리 재생

    char map_backup[ROW][COL]; // 초기 맵 상태를 백업할 배열
    // 메인 맵 (마을) 정의
    char map[ROW][COL] = {
        "1111111111111111111111111111111111111111", // 1: 벽/나무, m: 상자 (이동 불가)
        "1mmm000000000000000000000000000000000001", // 0: 빈 공간, 7: 보스 던전 입구
        "1m7m000000000000000000000000000000000001",
        "1mmm000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "100000000000000000000000000000000000mmm1",
        "100000000000000000000000000000000000m4m1", // 4: 던전 2 입구
        "100000000000000000000000000000000000mmm1",
        "100000000000000z0000000c0000000000000001", // z: 물약 상점, c: 카지노
        "1000000000000000000000000000000000000001",
        "1mmm000000000000000000000000000000000001",
        "1m5m000000000000000000000000000000000001", // 5: 던전 3 입구
        "1mmm000000000000000n00000000000000000001", // n: NPC
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "100000000000000000000000000000000000mmm1",
        "100000000000000000000000000000000000m3m1", // 3: 던전 1 입구
        "100000000000000000000000000000000000mmm1",
        "1111111111111111111111111111111111111111"
    };
    // 던전 1 맵 정의 (몬스터 스폰 위치 등)
    char map1[ROW][COL] = {
        "1111111111111111111111111111111111111111",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000901", // 9: 마을 귀환 지점
        "1111111111111111111111111111111111111111"
    };
    // 던전 2 맵 정의
    char map2[ROW][COL] = {
        "1111111111111111111111111111111111111111",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000901",
        "1111111111111111111111111111111111111111"
    };
    // 던전 3 맵 정의 (히든 던전 입구 포함)
    char map3[ROW][COL] = {
        "1111111111111111111111111111111111111111",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000600001", // 6: 히든 던전 입구 (열쇠 필요)
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000901",
        "1111111111111111111111111111111111111111"
    };
    // 던전 4 맵 정의 (히든 던전)
    char map4[ROW][COL] = {
        "1111111111111111111111111111111111111111",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000501", // 5: 던전 3으로 돌아가는 입구 (가정)
        "1111111111111111111111111111111111111111"
    };
    // 던전 5 맵 정의 (최종 보스 던전)
    char map5[ROW][COL] = {
        "1111111111111111111111111111111111111111",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000901",
        "1111111111111111111111111111111111111111"
    };

    // int playerX = 1, playerY = 18; // 플레이어 초기 위치 (전역 변수로 선언됨)
    int npcX = 19;  // NPC의 X 좌표
    int npcY = 12;  // NPC의 Y 좌표
    int fire_dx = 1, fire_dy = 0; // 파이어볼의 초기 발사 방향 (오른쪽)
    char* currentMapName = "마을"; // 현재 맵 이름
    int gold = 1000; // 초기 골드
    int potion1_hp = 0; // 하급 물약 개수
    int potion2_hp = 0; // 중급 물약 개수
    int potion3_hp = 0; // 상급 물약 개수
    int playerHP = 100; // 플레이어 현재 체력
    int playerMaxHP = 100; // 플레이어 최대 체력
    int a=0; // 던전 5(보스맵)에 진입 시 스토리 트리거를 위한 변수
    memcpy(map_backup, map, sizeof(map)); // 초기 맵 상태를 백업
    enableRawMode(); // 터미널 원시 모드 활성화

    // 메인 게임 루프 (게임 재시작을 위해 외부 루프 추가)
    while (1) {
        // 던전 5(보스맵)에 들어갔을 때 스토리 및 리셋 로직
        if (a==32){ // 특정 값 (이전에 스토리 재생 후 a++ 로 31이 되었고, 다시 이 루프를 돌 때 32가 됨)
            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            printf("⚫ 최종 던전 5에 입장하셨습니다...\n\n");
            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            usleep(1000000); // 1초 대기
            memcpy(map, map5, sizeof(map)); // 맵을 던전 5 맵으로 변경
            playerX = 1; // 플레이어 위치 초기화
            playerY = 18;
            currentMapName = "던전 5 (최종 보스)"; // 현재 맵 이름 변경
            monsterCount = 0; // 몬스터 초기화
            spawnMonster(20, 10, 4); // 혼테일 (보스) 몬스터 생성
            a++; // 스토리 트리거 변수 증가
        }
        if (a==31){ // 스토리 재생 후 플레이어 부활 로직
            printf("\033[H\033[J"); // 화면 지우기
            printf("\n\n\n\n\n");
            printf("------------------------------------------------------- \n\n");            
            printf("              보스전을 시작 합니다.  \n");
            printf("-------------------------------------------------------\n");
            printf("\n\n          아무 키나 눌러 재시작하세요...\n");
            fflush(stdout);
            getch(); // 키 입력 대기
            resetGame(&playerX, &playerY, &playerHP, &playerMaxHP, &currentMapName, map, map_backup); // 게임 상태 초기화 (마을로 복귀 등)
            a++; // 스토리 트리거 변수 증가
            // 여의주 아이템 추가
            inventory[0] += 1; // 여의주 조각 1개 추가 (이 부분은 논리적으로 맞지 않음. 4개를 모아야 여의주인데, 1개만 주는 형태)
            inventory[9] = 1; // 여의주 아이템 획득 플래그 설정 (9번 인덱스가 여의주 완성 여부인 듯)
            // 여의주 스토리 후 플레이어 이모지 변경
            currentEmoji = 1;  // 플레이어를 용으로 변경
            playerEmojis[currentEmoji] = "🐉 "; // 용 이모지 적용
            printf("\n🎉 플레이어 이모지가 뱀에서 용으로 바뀌었습니다!\n");            
        }
        if (a>=1 && a<30){ // 스토리 트리거 변수 a가 1 이상 30 미만일 때 계속 증가
            a++;
        }
        

        // 게임오버 체크
        if (playerHP <= 0) {
            printf("\033[H\033[J"); // 화면 지우기
            printf("\n\n\n\n\n");
            printf("------------------- 💀 게임 오버 💀 ------------------- \n\n");            
            printf("          플레이어의 체력이 모두 소진되었습니다.  \n");
            printf("          마을로 돌아가 재시작합니다...          \n\n");
            printf("-------------------------------------------------------\n");
            printf("\n\n          아무 키나 눌러 재시작하세요...\n");
            fflush(stdout);
            getch(); // 키 입력 대기
            resetGame(&playerX, &playerY, &playerHP, &playerMaxHP, &currentMapName, map, map_backup); // 게임 리셋
            continue; // 메인 게임 루프 다시 시작
        }

        static int firstDraw = 1; // 첫 화면 그리기 플래그 (사용되지 않는 듯)
        printf("\033[2J\033[H"); // 화면 지우기 및 커서 홈으로 이동
        // 맵 범례 출력
        printf("🟢 : 던전1 🔵 : 던전2 🔴 : 던전3 🚪 : 히든맵 ⚫ : 보스 🌀 : 마을귀환 🏥 : 물약상점 🕌 : 카지노 🤖 : NPC\n\n");
        printf("\n🌍 현재 맵: [%s]", currentMapName); // 현재 맵 이름 출력
        printf("                                                                            플레이어 위치: (%d, %d)\n", playerX, playerY); // 플레이어 위치 출력

        for (int i = 0; i < ROW; i++) { // 맵 출력
            for (int j = 0; j < COL; j++) {
                if (i == playerY && j == playerX) { // 플레이어 위치
                    printf("%s", playerEmojis[currentEmoji]); // 플레이어 이모지 출력
                    continue; // 다음 칸으로
                }
                int fireballHere = 0; // 파이어볼 존재 여부 플래그
                for (int f = 0; f < MAX_FIREBALLS; f++) { // 파이어볼 위치 확인
                    if (fireballs[f].active && fireballs[f].x == j && fireballs[f].y == i) {
                        printf(fireballs[f].is_monster_bullet ? "💧 " : "🔥 "); // 몬스터 탄환이면 💧, 플레이어 파이어볼이면 🔥
                        fireballHere = 1; // 파이어볼 존재 플래그 설정
                        break;
                    }
                }
                if (fireballHere) continue; // 파이어볼이 있으면 다른 것 출력 안 하고 다음 칸으로
                
                int monsterHere = 0; // 몬스터 존재 여부 플래그
                for (int m = 0; m < monsterCount; m++) { // 몬스터 위치 확인
                    if (monsters[m].alive && monsters[m].x == j && monsters[m].y == i) { // 몬스터 본체 위치
                        printf("%s ", monsterEmojis[monsters[m].type]); // 몬스터 이모지 출력
                        monsterHere = 1; // 몬스터 존재 플래그 설정
                        break;
                    }
              
                }
                if (monsterHere) continue; // 몬스터가 있으면 다른 것 출력 안 하고 다음 칸으로

                // 맵 요소 출력
                if (map[i][j] == '0') printf("   "); // 빈 공간
                else if (map[i][j] == '1') printf("🌴 "); // 벽 (나무 이모지)
                else if (map[i][j] == '2') printf("🟥 "); // 장애물 (빨간 사각형 이모지, 사용되지 않는 듯)
                else if (map[i][j] == '3') printf("🟢 "); // 던전 1 입구
                else if (map[i][j] == '4') printf("🔵 "); // 던전 2 입구
                else if (map[i][j] == '5') printf("🔴 "); // 던전 3 입구
                else if (map[i][j] == '6') printf("🚪 "); // 히든 던전 입구
                else if (map[i][j] == '7') printf("⚫ "); // 보스 던전 입구
                else if (map[i][j] == '9') printf("🌀 "); // 마을 귀환 지점
                else if (map[i][j] == 'z') printf("🏥 "); // 물약 상점
                else if (map[i][j] == 'c') printf("🕌 "); // 카지노
                else if (map[i][j] == 'n') printf("🤖 "); // NPC
                else if (map[i][j] == 'm') printf("🟫 "); // 상자 (갈색 사각형 이모지)
            }
            printf("\n"); // 한 행 출력 후 줄 바꿈
        }

        // 상태창 직접 출력 추가
        printf("❤️   HP: %d/%d", playerHP, playerMaxHP); // 플레이어 체력 출력
        printf("                                                                                                       💰 Gold: %d\n", gold); // 골드 출력

        // ✅ 퀘스트 출력 코드 추가
        char* questNames[5] = { // 퀘스트 이름 배열
            "달팽이", "도마뱀", "독거미", "드라큘라", "혼테일"
        };

        // 퀘스트 목표 수치
        int questKillTargets[5] = {10, 10, 10, 1, 1};    // 퀘스트 몬스터 처치 목표 수
        int questItemTargets[5] = {5, 5, 5, 1, 1};     // 퀘스트 아이템 수집 목표 수
        char* questItemNames[5] = { // 퀘스트 아이템 이름 배열
            "등껍질",        // 달팽이 아이템
            "비늘",          // 도마뱀 아이템
            "송곳니",        // 독거미 아이템
            "심장",          // 드라큘라 아이템
            "정수"           // 혼테일 아이템
        };

        printf("\n🎯  퀘스트 진행 상태 \n");
        for (int i = 0; i < 5; i++) {
            if (questAccepted[i] && !questCompleted[i]) { // 퀘스트 수락했지만 완료되지 않은 경우
                printf("  %d. %s: 진행 중... (%d/%d 마리, %s: %d/%d)\n",
                    i + 1, questNames[i],
                    questKillCount[i], questKillTargets[i],
                    questItemNames[i], questItemCount[i], questItemTargets[i]);
            } else if (questCompleted[i] && !rewardGiven[i]) { // 퀘스트 완료했지만 보상 받지 않은 경우
                printf("  %d. %s 퀘스트 완료됨! (보상 수령 대기 중) 🎁\n", i + 1, questNames[i]);
            } else if (questCompleted[i] && rewardGiven[i]) { // 퀘스트 완료하고 보상까지 받은 경우
                printf("  %d. %s: 완료 ✅\n", i + 1, questNames[i]);
            }
        }



        if (questAccepted[0] && !questCompleted[0])
            printf(" "); // 퀘스트 진행 중일 때는 아무것도 출력하지 않음
        else if (questCompleted[0] && !rewardGiven[0]) { // 퀘스트 1 완료 (보상 미수령)
            printf("🤖 NPC: “잘했네. 이건 보상이네.”\n");
            gold += 100; // 골드 지급
            inventory[0] += 1; // 여의주 조각 지급
            rewardGiven[0] = 1; // 보상 지급 플래그 설정
            printf("💰 보상: 골드 +100, 여의주 조각 +1\n");
            usleep(1500000);
            playerX = npcX + 1;  // NPC 오른쪽으로 강제 이동 (NPC와 겹치지 않게)
            playerY = npcY;
        }

        if (questAccepted[1] && !questCompleted[1])
            printf(" ");
        else if (questCompleted[1] && !rewardGiven[1]) { // 퀘스트 2 완료 (보상 미수령)
            printf("🤖 NPC: “도마뱀까지 해치우다니! 실력 인정하네.”\n");
            gold += 200;
            inventory[0] += 1;
            rewardGiven[1] = 1;
            printf("💰 보상: 골드 +200, 여의주 조각 +1\n");
            usleep(1500000);
            playerX = npcX + 1;
            playerY = npcY;
        }

        if (questAccepted[2] && !questCompleted[2])
            printf(" ");
        else if (questCompleted[2] && !rewardGiven[2]) { // 퀘스트 3 완료 (보상 미수령)
            printf("🤖 NPC: “독거미까지 해치우다니! 실력 인정하네.”\n");
            gold += 1000; // 보상이 커짐
            inventory[0] += 1;
            rewardGiven[2] = 1;
            printf("💰 보상: 골드 +1000, 여의주 조각 +1\n");
            usleep(1500000);
            playerX = npcX + 1;
            playerY = npcY;
        }

        if (questAccepted[3] && !questCompleted[3])
            printf(" ");
        else if (questCompleted[3] && !rewardGiven[3]) { // 퀘스트 4 완료 (보상 미수령)
            printf("🤖 NPC: “드라큘라 까지 해치우다니! 실력 인정하네.”\n");
            gold += 2000; // 보상이 더 커짐
            inventory[0] += 1;
            rewardGiven[3] = 1;
            printf("💰 보상: 골드 +2000, 여의주 조각 +1\n");
            usleep(1500000);
            playerX = npcX + 1;
            playerY = npcY;
        }
        
        printf("\n\n 포션 ▶ 1,2,3 키로 즉시 사용 \n");
        printf(" 💚 하급 : %d 개 💙 중급 : %d 개 💖 상급 : %d 개 \n", potion1_hp, potion2_hp, potion3_hp);
        
        char input = getch_nonblock(); // 비블로킹 방식으로 키 입력 받기
        // 파이어볼 발사
        if (input == 'f' || input == 'F') {
            spawnFireball(playerX, playerY, fire_dx, fire_dy, 0, 10); // 기본 파이어볼 10 데미지
        }
        // 메테오 스킬 발동
        if (input == 'R' || input == 'r') {
            castMeteor();
        }

        // 드래곤 브레스 스킬 발동
        if (input == 'E' || input == 'e') {
            castDragonBreath(playerX, playerY, fire_dx, fire_dy, 0);
        }

        if (input == 0) { // 입력이 없으면 (0 반환)
            updateFireballs(map, &playerHP, &playerMaxHP, playerX, playerY); // 파이어볼 업데이트
            updateMonsters(playerX, playerY, map); // 몬스터 업데이트
            usleep(30000); // 30ms 대기 (프레임 속도 조절)
            continue; // 루프의 다음 반복으로
        }
        if (input == 0x1b) { // ESC 키 (방향키의 시작 코드)
            char next1 = getch(); // 다음 문자 읽기
            char next2 = getch(); // 그다음 문자 읽기
            if (next1 == '[') { // ESC [ ... 형태의 방향키 입력
                if (next2 == 'A') { input = 'A'; fire_dx = 0; fire_dy = -1; dirX = 0; dirY = -1; } // ↑ (방향키 입력 시 발사 방향도 업데이트)
                else if (next2 == 'B') { input = 'B'; fire_dx = 0; fire_dy = 1; dirX = 0; dirY = 1; }  // ↓
                else if (next2 == 'C') { input = 'C'; fire_dx = 1; fire_dy = 0; dirX = 1; dirY = 0; }  // →
                else if (next2 == 'D') { input = 'D'; fire_dx = -1; fire_dy = 0; dirX = -1; dirY = 0; } // ←
            }
        }
        if (input == '1') { // 하급 물약 사용
            if (potion1_hp > 0) {
                potion1_hp--;
                playerHP += 10;
                if (playerHP > playerMaxHP) playerHP = playerMaxHP; // 최대 체력 초과 방지
                printf("\n 💚 하급 포션 사용! 체력 +10\n");
            } else {
                printf("\n❗ 하급 포션이 없습니다!\n");
            }
            usleep(1000000);
            continue;
        }
        if (input == '2') { // 중급 물약 사용
            if (potion2_hp > 0) {
                potion2_hp--;
                playerHP += 30;
                if (playerHP > playerMaxHP) playerHP = playerMaxHP;
                printf("\n 💙 중급 포션 사용! 체력 +30\n");
            } else {
                printf("\n❗ 중급 포션이 없습니다!\n");
            }
            usleep(1000000);
            continue;
        }
        if (input == '3') { // 상급 물약 사용
            if (potion3_hp > 0) {
                potion3_hp--;
                playerHP += 70;
                if (playerHP > playerMaxHP) playerHP = playerMaxHP;
                printf("\n 💖 상급 포션 사용! 체력 +70\n");
            } else {
                printf("\n❗ 상급 포션이 없습니다!\n");
            }
            usleep(1000000);
            continue;
        }
        if (input == 'q' || input == 'Q') { // 'q' 또는 'Q' 입력 시 게임 종료
            break;
        }
        if (input == 'i' || input == 'I') { // 'i' 또는 'I' 입력 시 인벤토리 열기
            while (1) {
                printf("\033[H\033[J"); // 화면 지우기
                printf("\n-------------------- 인벤토리 확인 --------------------\n");
                printf("\n");
                printf("              💰  골드: %dG\n", gold);
                printf("              💚  하급 체력 물약[ %d개 ]\n", potion1_hp);
                printf("                  - 체력 회복량 + 10 \n\n");
                printf("              💙  중급 체력 물약[ %d개 ]\n", potion2_hp);
                printf("                  - 체력 회복량 + 30 \n\n");
                printf("              💖  상급 체력 물약[ %d개 ]\n", potion3_hp);
                printf("                  - 체력 회복량 + 70 \n\n");
                if (inventory[0] <= 4){ // 여의주 조각이 4개 이하일 때
                    printf("              ✴️  여의주 조각 : %d 개\n", inventory[0]);
                    printf("                  - 4조각을 모으면 여의주가 됩니다. \n\n");
                }
                if (inventory[9] == 1)  // 여의주 아이템이 인벤토리에 있으면 출력
                    printf("              🏆  여의주\n\n");
                if (hasKey == 1) { // 열쇠가 있다면 출력
                    printf("              🗝️  히든 던전 열쇠\n");
                }
                printf("\n");
                printf("-------------------------------------------------------\n");
                printf("\n");
                printf("            ( i ) 키를 다시 누르면 돌아갑니다...\n");

                char temp = getch(); // 인벤토리 종료를 위한 키 입력 대기
                if (temp == 'i' || temp == 'I') break; // 'i' 또는 'I' 입력 시 종료
            }
            continue; // 메인 게임 루프 다시 시작
        }

        int newX = playerX, newY = playerY; // 새로운 플레이어 위치 계산
        if (input == 'A') newY--; // 위로 이동
        else if (input == 'B') newY++; // 아래로 이동
        else if (input == 'D') newX--; // 왼쪽으로 이동
        else if (input == 'C') newX++; // 오른쪽으로 이동

        // 새로운 위치가 유효하고 벽('1')이나 장애물('2')이 아니면 이동 허용
        if (newX >= 0 && newX < COL && newY >= 0 && newY < ROW && map[newY][newX] != '1' && map[newY][newX] != '2') {
            // 플레이어와 몬스터 충돌 체크 (플레이어가 몬스터 칸으로 이동 시 데미지)
            bool hit_monster = false;
            for (int m = 0; m < monsterCount; m++) {
                if (monsters[m].alive && monsters[m].x == newX && monsters[m].y == newY) {
                    playerHP -= 10; // 몬스터와 충돌 시 10 데미지
                    if (playerHP < 0) playerHP = 0;
                    hit_monster = true;
                    break;
                }
            }
            if (!hit_monster) { // 몬스터와 충돌하지 않았다면 이동
                playerX = newX;
                playerY = newY;
            }
        }

        // 맵 이동 및 상호작용 처리
        if (map[playerY][playerX] == '3') { // 던전 1 입구
            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            printf("🟢 던전 1에 입장하셨습니다...\n\n");
            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            usleep(1000000); // 1초 대기
            memcpy(map, map1, sizeof(map)); // 맵을 던전 1로 변경
            playerX = 1; // 플레이어 위치 초기화
            playerY = 18;
            currentMapName = "던전 1"; // 맵 이름 변경
            monsterCount = 0; // 몬스터 초기화
            spawnMonster(10, 5, 0);  // 달팽이 몬스터 생성
            spawnMonster(15, 10, 0);
            spawnMonster(20, 7, 0);
            spawnMonster(25, 12, 0);
            spawnMonster(30, 9, 0);
        } else if (map[playerY][playerX] == '4') { // 던전 2 입구
            if (!questAccepted[1]) { // 퀘스트 2를 수락하지 않았다면
                printf("\n❗ 퀘스트 2를 수락해야 던전 2에 입장할 수 있습니다.\n");
                printf("아무 키나 눌러 계속...\n");
                getch();
                continue;
            }

            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            printf("🔵 던전 2에 입장하셨습니다...\n\n");
            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            usleep(1000000);
            memcpy(map, map2, sizeof(map));
            playerX = 1;
            playerY = 18;
            currentMapName = "던전 2";
            monsterCount = 0;
            spawnMonster(10, 5, 1); // 도마뱀 몬스터 생성
            spawnMonster(15, 10, 1);
            spawnMonster(20, 7, 1);
            spawnMonster(25, 12, 1);
            spawnMonster(30, 9, 1);
        } else if (map[playerY][playerX] == '5') { // 던전 3 입구
            if (!questAccepted[2]) { // 퀘스트 3을 수락하지 않았다면
                printf("\n❗ 퀘스트 3을 수락해야 던전 3에 입장할 수 있습니다.\n");
                printf("아무 키나 눌러 계속...\n");
                getch();
                continue;
            }

            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            printf("🔴 던전 3에 입장하셨습니다...\n\n");
            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            usleep(1000000);
            memcpy(map, map3, sizeof(map));
            playerX = 1;
            playerY = 18;
            currentMapName = "던전 3";
            monsterCount = 0;
            spawnMonster(10, 5, 2); // 독거미 몬스터 생성
            spawnMonster(15, 10, 2);
            spawnMonster(20, 7, 2);
            spawnMonster(25, 12, 2);
            spawnMonster(30, 9, 2);
        } else if (map[playerY][playerX] == '6') { // 히든 던전 입구
            if (hasKey) { // 열쇠가 있다면 진입 가능
                printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
                printf("🚪 히든 던전 4에 입장하셨습니다...\n\n");
                printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
                usleep(1000000);
                memcpy(map, map4, sizeof(map));
                playerX = 1;
                playerY = 18;
                currentMapName = "던전 4 (히든 맵)";
                monsterCount = 0;
                spawnMonster(14, 8, 3); // 드라큘라 몬스터 생성
            } else { // 열쇠가 없다면
                printf("\n❗ 열쇠가 없어서 들어갈 수 없습니다...\n");
                printf("아무 키나 누르면 계속합니다...\n");
                getch();
            }
        } else if (map[playerY][playerX] == '7') { // 보스 던전 입구
            if (!questAccepted[4]) { // 최종 퀘스트를 수락하지 않았다면
                printf("\n❗ 최종 퀘스트를 수락해야 최종 던전에 입장할 수 있습니다.\n");
                printf("아무 키나 눌러 계속...\n");
                getch();
                continue;
            }

            // 던전 5 입장 전 메시지
            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            printf("⚫ 최종 던전 5에 입장하셨습니다...\n\n");
            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            usleep(1000000); // 1초 대기

                        
            // 여의주 관련 아이템 교환 및 대화 (이 부분은 플레이어가 보스 던전 입장 시 조건에 따라 스토리 트리거)
            if (inventory[0] >= 4) { // 여의주 조각이 4개 이상이라면
                if (a < 30) { // a가 30 미만일 때 (스토리 미발동 상태)
                    a = 1; // 스토리 트리거 변수 설정 (중간 스토리 재생)
                }
                
            }

            // 던전 5로 맵 변경 (보스전 시작)
            memcpy(map, map5, sizeof(map));
            playerX = 1;
            playerY = 18;
            currentMapName = "던전 5 (최종 보스)";
            monsterCount = 0;

            // 몬스터 생성 및 추가
            spawnMonster(10, 5, 4);  // 혼테일 (보스) 몬스터 생성

        } else if (map[playerY][playerX] == '9') { // 마을 귀환 지점
            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            printf("🏡 마을로 돌아왔습니다...\n\n");
            printf("-----------------------------------------------------------------------------------------------------------------------\n\n");
            usleep(1000000);
            memcpy(map, map_backup, sizeof(map)); // 맵을 백업된 마을 맵으로 복구
            playerX = 1;
            playerY = 18;
            currentMapName = "마을";
            monsterCount = 0; // 몬스터 초기화
            playerHP = playerMaxHP;  // 🩺 마을 복귀 시 체력 전부 회복
        } else if (map[playerY][playerX] == 'c') { // 카지노 입구 (NPC처럼 가까이 가야 상호작용)
            int nearCasino = 0; // 카지노 근처에 있는지 확인 플래그
            for (int dy = -1; dy <= 1 && !nearCasino; dy++) { // 플레이어 주변 3x3 칸 확인
                for (int dx = -1; dx <= 1 && !nearCasino; dx++) {
                    int ny = playerY + dy;
                    int nx = playerX + dx;
                    if (ny >= 0 && ny < ROW && nx >= 0 && nx < COL && map[ny][nx] == 'c') {
                        nearCasino = 1; // 카지노 근처에 있음
                    }
                }
            }
            if (nearCasino) { // 카지노 근처라면
                printf("\n🕌 카지노에 도착했습니다.\n");
                printf("게임을 시작하시겠습니까? (Y/N): ");
                fflush(stdout);
                char choice;
                while (1) { // Y/N 입력 대기
                    choice = getch();
                    if (choice == 'y' || choice == 'Y') {
                        printf("\n카지노 게임을 시작합니다...\n");
                        usleep(1000000);
                        playCasino(&gold); // 카지노 게임 시작
                        break;
                    } else if (choice == 'n' || choice == 'N') {
                        printf("\n카지노 입장을 취소했습니다.\n");
                        usleep(1000000);
                        break;
                    } 
                }
                // 카지노 상호작용 후 플레이어 위치를 카지노 입구 옆으로 이동시키는 로직 (겹치지 않게)
                if (map[playerY][playerX + 1] == '0') playerX++;
                else if (map[playerY][playerX - 1] == '0') playerX--;
                else if (map[playerY - 1][playerX] == '0') playerY--;
                else if (map[playerY + 1][playerX] == '0') playerY++;
            }

        } else if (map[playerY][playerX] == 'z') { // 물약 상점 입구 (가까이 가면 상호작용)
            printf("\n🏥 물약상점에 도착했습니다. \n");
            openPotionShop(&gold, &potion1_hp, &potion2_hp, &potion3_hp); // 물약 상점 열기
            // 물약 상점 상호작용 후 플레이어 위치를 상점 입구 옆으로 이동시키는 로직
            if (map[playerY][playerX + 1] == '0') playerX++;
            else if (map[playerY][playerX - 1] == '0') playerX--;
            else if (map[playerY - 1][playerX] == '0') playerY--;
            else if (map[playerY + 1][playerX] == '0') playerY++;
            
            
        } else if (map[playerY][playerX] == 'n') { // NPC와 상호작용
            // 퀘스트 1 완료 조건 확인 및 보상 지급
            if (questAccepted[0] && !questCompleted[0] &&
                questKillCount[0] >= 10 && questItemCount[0] >= 5) {
                questCompleted[0] = 1; // 퀘스트 완료 처리
                rewardGiven[0] = 1; // 보상 지급 플래그 설정
                gold += 100; // 골드 지급
                inventory[0] += 1; // 여의주 조각 지급
                printf("\n🤖 NPC: “훌륭하네. 달팽이 처치와 등껍질 수집을 모두 해냈군.”\n");
                printf("💰 보상: 골드 +100, 여의주 조각 +1\n");
                usleep(1500000);
                playerX = npcX + 1;  // NPC 오른쪽으로 강제 이동
                playerY = npcY;
                continue; // 다른 대사와 겹치지 않도록
            }
            // 퀘스트 2 완료 조건 확인 및 보상 지급
            if (questAccepted[1] && !questCompleted[1] &&
                questKillCount[1] >= 10 && questItemCount[1] >= 5) {
                questCompleted[1] = 1;
                rewardGiven[1] = 1;
                gold += 200;
                inventory[0] += 1;
                printf("\n🤖 NPC: “도마뱀까지 해치우다니! 실력 인정하네.”\n");
                printf("💰 보상: 골드 +200, 여의주 조각 +1\n");
                usleep(1500000);
                playerX = npcX + 1;
                playerY = npcY;
                continue;
            }

            // 퀘스트 3 완료 조건 확인 및 보상 지급
            if (questAccepted[2] && !questCompleted[2] &&
                questKillCount[2] >= 10 && questItemCount[2] >= 5) {
                questCompleted[2] = 1;
                rewardGiven[2] = 1;
                gold += 300;
                inventory[0] += 1;
                printf("\n🤖 NPC: “맹독 거미도 처치하다니, 이젠 진짜 용사 같군.”\n");
                printf("💰 보상: 골드 +300, 여의주 조각 +1\n");
                usleep(1500000);
                playerX = npcX + 1;
                playerY = npcY;
                continue;
            }

            // 퀘스트 4 완료 조건 확인 및 보상 지급
            if (questAccepted[3] && !questCompleted[3] &&
                questKillCount[3] >= 1 && questItemCount[3] >= 1) {
                questCompleted[3] = 1;
                rewardGiven[3] = 1;
                gold += 500;
                inventory[0] += 1;
                printf("\n🤖 NPC: “드라큘라의 심장을 얻었다니... 대단하군.”\n");
                printf("💰 보상: 골드 +500, 여의주 조각 +1\n");
                usleep(1500000);
                playerX = npcX + 1;
                playerY = npcY;
                continue;
            }

            // 퀘스트 5 완료 조건 확인 및 보상 지급
            if (questAccepted[4] && !questCompleted[4] &&
                questKillCount[4] >= 1 && questItemCount[4] >= 1) {
                questCompleted[4] = 1;
                rewardGiven[4] = 1;
                gold += 1000;
                inventory[4] += 1; // 인벤토리의 4번 인덱스에 아이템 추가 (혼테일 정수)
                printf("\n🤖 NPC: “혼테일을 쓰러뜨리다니… 복수는 완성되었도다.”\n");
                printf("🎉 최종 보상: 골드 +1000, 혼테일의 정수 +1\n");
                usleep(2000000);
                playerX = npcX + 1;
                playerY = npcY;
                continue;
            }
            // 퀘스트 멘트 및 수락 여부 (순서대로 퀘스트를 제공)
            if (!questAccepted[0]) { // 퀘스트 1을 수락하지 않았다면
                printf("\n🤖 NPC: “곤… 복수를 위해선 먼저 몸부터 단련해야 해. 저 앞 숲에 달팽이 무리들이 나타났다고 하더군.\n");
                printf("          먼저 그 녀석들부터 처치하고, 달팽이 등껍질을 모아와 줘.”\n");
                printf("          “달팽이가 있는 숲은 🟢 이라네”\n");
                printf("\n📜 퀘스트를 수락하시겠습니까? (Y/N): ");
                fflush(stdout);

                char q;
                while (1) { // Y/N 입력 대기
                    q = getch();
                    if (q == 'y' || q == 'Y') {
                        questAccepted[0] = 1; // 퀘스트 1 수락
                        printf("\n✅ 퀘스트 1 [달팽이를 죽여라]를 수락했습니다!\n");
                        usleep(1500000);
                        playerX = npcX + 1;  // NPC 오른쪽으로 강제 이동
                        playerY = npcY;
                        break;
                    } else if (q == 'n' || q == 'N') {
                        printf("\n❗ 퀘스트 수락을 취소했습니다.\n");
                        usleep(1000000);
                        playerX = npcX + 1;
                        playerY = npcY;
                        break;
                    }
                }
            } else if (questAccepted[0] && questCompleted[0] && !questAccepted[1]) { // 퀘스트 1 완료 후 퀘스트 2 미수락 시
                printf("\n🤖 NPC: “달팽이 따위로는 복수를 할 수 없어. 좀 더 강한 적을 상대해야지.\n");
                printf("          숲 속 깊은 곳에 숲 도마뱀이 출몰한다고 하더군.”\n");
                printf("          “도마뱀이 출몰하는 숲은 🔵 이라네”\n");
                printf("\n📜 퀘스트 2 [숲 도마뱀을 죽여라]를 수락하시겠습니까? (Y/N): ");
                fflush(stdout);

                char q;
                while (1) {
                    q = getch();
                    if (q == 'y' || q == 'Y') {
                        questAccepted[1] = 1;
                        printf("\n✅ 퀘스트 2 [숲 도마뱀을 죽여라]를 수락했습니다!\n");
                        usleep(1500000);
                        playerX = npcX + 1;
                        playerY = npcY;
                        break;
                        
                    } else if (q == 'n' || q == 'N') {
                        printf("\n❗ 퀘스트 수락을 취소했습니다.\n");
                        usleep(1000000);
                        playerX = npcX + 1;
                        playerY = npcY;
                        break;
                    }
                }
            } else if (questAccepted[1] && questCompleted[1] && !questAccepted[2]) { // 퀘스트 2 완료 후 퀘스트 3 미수락 시
                printf("\n🤖 NPC: “그대, 독거미의 맹독도 감당할 수 있을까? 던전 3에서 기다리고 있을 걸세.”\n");
                printf("          “독거미의 던전은 🔴 이라네”\n");
                printf("\n📜 퀘스트 3 [맹독 거미를 처치하라]를 수락하시겠습니까? (Y/N): ");
                fflush(stdout);
                char q;
                while (1) {
                    q = getch();
                    if (q == 'y' || q == 'Y') {
                        questAccepted[2] = 1;
                        printf("\n✅ 퀘스트 3 [맹독 거미를 처치하라]를 수락했습니다!\n");
                        usleep(1500000);
                        playerX = npcX + 1;
                        playerY = npcY;
                        break;
                        
                    } else if (q == 'n' || q == 'N') {
                        printf("\n❗ 퀘스트 수락을 취소했습니다.\n");
                        usleep(1000000);
                        playerX = npcX + 1;
                        playerY = npcY;
                        break;
                        
                    }
                }
            } else if (questAccepted[2] && questCompleted[2] && !questAccepted[3]) { // 퀘스트 3 완료 후 퀘스트 4 미수락 시
                printf("\n🤖 NPC: “흡혈의 왕, 드라큘라가 그대를 기다리고 있다.”\n");
                printf("          “독거미의 던전으로 들어가 🚪 문을 열면 드라큘라가 있다네”\n");
                printf("\n📜 퀘스트 4 [드라큘라를 처치하라]를 수락하시겠습니까? (Y/N): ");
                fflush(stdout);
                char q;
                while (1) {
                    q = getch();
                    if (q == 'y' || q == 'Y') {
                        questAccepted[3] = 1;
                        printf("\n✅ 퀘스트 4 [드라큘라를 처치하라]를 수락했습니다!\n");
                        usleep(1500000);
                        playerX = npcX + 1;
                        playerY = npcY;
                        break;
                        
                    } else if (q == 'n' || q == 'N') {
                        printf("\n❗ 퀘스트 수락을 취소했습니다.\n");
                        usleep(1000000);
                        playerX = npcX + 1;
                        playerY = npcY;
                        break;
                        
                    }
                }
            } else if (questAccepted[3] && questCompleted[3] && !questAccepted[4]) { // 퀘스트 4 완료 후 퀘스트 5 미수락 시
                printf("\n🤖 NPC: “최종 보스… 혼테일을 상대할 준비가 되었는가?”\n");
                printf("\n📜 퀘스트 5 [혼테일을 쓰러뜨려라]를 수락하시겠습니까? (Y/N): ");
                fflush(stdout);
                char q;
                while (1) {
                    q = getch();
                    if (q == 'y' || q == 'Y') {
                        questAccepted[4] = 1;
                        printf("\n✅ 퀘스트 5 [혼테일을 쓰러뜨려라]를 수락했습니다!\n");
                        usleep(1500000);
                        playerX = npcX + 1;
                        playerY = npcY;
                        break;
                        
                    } else if (q == 'n' || q == 'N') {
                        printf("\n❗ 퀘스트 수락을 취소했습니다.\n");
                        usleep(1000000);
                        playerX = npcX + 1;
                        playerY = npcY;
                        break;
                        
                    }
                }
            } else if (questAccepted[4] && questCompleted[4]) { // 모든 퀘스트 완료 시 (엔딩 스토리)
                printf("\n🤖 NPC: “그대는 모든 복수를 완수했도다. 진정한 용사여.”\n");
                usleep(2000000);
                    // --- 엔딩 스토리 데이터 ---
                const char** ending_arts[] = { // 엔딩 스토리 삽화 배열
                    dragonFight, dragonFight, NULL, NULL, NULL, dragon, dragon, NULL
                };
                const int ending_art_lines[] = { // 각 삽화의 라인 수 배열
                    sizeof(dragonFight)/sizeof(dragonFight[0]), sizeof(dragonFight)/sizeof(dragonFight[0]), 0, 0, 0,
                    sizeof(dragon)/sizeof(dragon[0]), sizeof(dragon)/sizeof(dragon[0]), 0
                };
                const char* ending_texts[] = { // 엔딩 스토리 대사
                    "곤과 혼테일의 마지막 결전은 천둥처럼 울려 퍼졌다.",
                    "치열한 싸움 끝에, 마침내 곤은 혼테일의 숨통을 끊었다.",
                    "쓰러진 혼테일의 몸에서 어둠이 걷히고, 천공의 둥지에는 다시 평화가 찾아왔다.",
                    "곤은 천천히 발걸음을 옮겨, 모든 것이 파괴된 천공의 둥지로 돌아갔다.",
                    "예전의 따뜻함과 생명이 가득했던 그곳은 이제 아무것도 남지 않은 텅 빈 공간이 되어 있었다.",
                    "그러나 곤은 알았다. 그곳에 담긴 기억과 자신이 지켜낸 평화가 새로운 시작을 위한 희망임을.",
                    "오랫동안 가슴속에 맺혔던 복수의 무거운 짐이 사라지고, 곤의 눈가에는 아픈 기억과 새로운 내일에 대한 다짐이 함께 맺혔다.",
                    "그리하여 어린 드래곤 곤의 여정은 마침내 끝이 났고, 그의 마음속에 새롭게 피어난 평화가 하늘 높이 퍼져나갔다.",
                };
                int ending_frameCount = sizeof(ending_texts) / sizeof(ending_texts[0]); // 엔딩 스토리 프레임 개수
                
                printf("\033[2J\033[1;1H"); // 화면 지우기
                sleep(1);
                playStory(ending_arts, ending_art_lines, ending_texts, ending_frameCount); // 엔딩 스토리 재생
                
                printf("\033[2J\033[1;1H"); // 화면 지우기
                break; // 메인 게임 루프 종료 (게임 종료)
            } else { // 현재 수행할 수 있는 퀘스트가 없을 때
                printf("\n🤖 NPC: 현재 수행할 수 있는 퀘스트가 없습니다.\n");
                usleep(1000000);
            }
        }

        updateFireballs(map, &playerHP, &playerMaxHP, playerX, playerY); // 파이어볼 업데이트
        updateMonsters(playerX, playerY, map); // 몬스터 업데이트
        usleep(30000); // 30ms 대기 (초당 약 33프레임)
    }

    disableRawMode(); // 터미널 원시 모드 비활성화
    tcsetattr(STDIN_FILENO, TCSANOW, &orig_termios); // 터미널 설정을 원래대로 복구
    printf("\n게임을 종료합니다. \n");
    return 0; // 프로그램 종료
}